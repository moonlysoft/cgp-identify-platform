var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import axios from "axios";
import FormData$1 from "form-data";
import { createMachine, assign, spawn, send, actions } from "xstate";
class HasuraStorageApi {
  constructor({ url }) {
    this.url = url;
    this.httpClient = axios.create({
      baseURL: this.url
    });
  }
  async upload(params) {
    const { formData } = params;
    try {
      const res = await this.httpClient.post("/files", formData, {
        headers: __spreadProps(__spreadValues(__spreadValues({}, this.generateUploadHeaders(params)), this.generateAuthHeaders()), {
          "Content-Type": "multipart/form-data"
        })
      });
      return { fileMetadata: res.data, error: null };
    } catch (error) {
      return { fileMetadata: null, error };
    }
  }
  async getPresignedUrl(params) {
    try {
      const { fileId } = params;
      const res = await this.httpClient.get(`/files/${fileId}/presignedurl`, {
        headers: __spreadValues({}, this.generateAuthHeaders())
      });
      return { presignedUrl: res.data, error: null };
    } catch (error) {
      return { presignedUrl: null, error };
    }
  }
  async delete(params) {
    try {
      const { fileId } = params;
      await this.httpClient.delete(`/files/${fileId}`, {
        headers: __spreadValues({}, this.generateAuthHeaders())
      });
      return { error: null };
    } catch (error) {
      return { error };
    }
  }
  setAccessToken(accessToken) {
    this.accessToken = accessToken;
    return this;
  }
  setAdminSecret(adminSecret) {
    this.adminSecret = adminSecret;
    return this;
  }
  generateUploadHeaders(params) {
    const { bucketId, name, id } = params;
    const uploadheaders = {};
    if (bucketId) {
      uploadheaders["x-nhost-bucket-id"] = bucketId;
    }
    if (id) {
      uploadheaders["x-nhost-file-id"] = id;
    }
    if (name) {
      uploadheaders["x-nhost-file-name"] = name;
    }
    return uploadheaders;
  }
  generateAuthHeaders() {
    if (!this.adminSecret && !this.accessToken) {
      return null;
    }
    if (this.adminSecret) {
      return {
        "x-hasura-admin-secret": this.adminSecret
      };
    }
    return {
      Authorization: `Bearer ${this.accessToken}`
    };
  }
}
class HasuraStorageClient {
  constructor({ url, adminSecret }) {
    this.url = url;
    this.api = new HasuraStorageApi({ url });
    this.setAdminSecret(adminSecret);
  }
  async upload(params) {
    let formData;
    if ("file" in params) {
      formData = new FormData$1();
      formData.append("file", params.file);
    } else {
      formData = params.formData;
    }
    const { fileMetadata, error } = await this.api.upload(__spreadProps(__spreadValues({}, params), {
      formData
    }));
    if (error) {
      return { fileMetadata: null, error };
    }
    if (!fileMetadata) {
      return { fileMetadata: null, error: new Error("Invalid file returned") };
    }
    return { fileMetadata, error: null };
  }
  getUrl(params) {
    return this.getPublicUrl(params);
  }
  getPublicUrl(params) {
    const { fileId } = params;
    return `${this.url}/files/${fileId}`;
  }
  async getPresignedUrl(params) {
    const { presignedUrl, error } = await this.api.getPresignedUrl(params);
    if (error) {
      return { presignedUrl: null, error };
    }
    if (!presignedUrl) {
      return { presignedUrl: null, error: new Error("Invalid file id") };
    }
    return { presignedUrl, error: null };
  }
  async delete(params) {
    const { error } = await this.api.delete(params);
    if (error) {
      return { error };
    }
    return { error: null };
  }
  setAccessToken(accessToken) {
    this.api.setAccessToken(accessToken);
    return this;
  }
  setAdminSecret(adminSecret) {
    this.api.setAdminSecret(adminSecret);
    return this;
  }
}
const INITIAL_FILE_CONTEXT = { progress: null, loaded: 0, error: null };
const createFileUploadMachine = () => createMachine({
  preserveActionOrder: true,
  schema: {
    context: {},
    events: {}
  },
  tsTypes: {},
  context: __spreadValues({}, INITIAL_FILE_CONTEXT),
  initial: "idle",
  on: {
    DESTROY: { actions: "sendDestroy", target: "stopped" }
  },
  states: {
    idle: {
      on: {
        ADD: { actions: "addFile" },
        UPLOAD: { cond: "hasFile", target: "uploading" }
      }
    },
    uploading: {
      entry: "resetProgress",
      on: {
        UPLOAD_PROGRESS: { actions: ["incrementProgress", "sendProgress"] },
        UPLOAD_DONE: "uploaded",
        UPLOAD_ERROR: "error",
        CANCEL: "idle"
      },
      invoke: { src: "uploadFile" }
    },
    uploaded: { entry: ["setFileMetadata", "sendDone"] },
    error: { entry: ["setError", "sendError"] },
    stopped: { type: "final" }
  }
}, {
  guards: {
    hasFile: (context, event) => !!context.file || !!event.file
  },
  actions: {
    incrementProgress: assign({
      loaded: (_, { loaded }) => loaded,
      progress: (_, { progress }) => progress
    }),
    setFileMetadata: assign({
      id: (_, { id }) => id,
      bucketId: (_, { bucketId }) => bucketId,
      progress: (_) => 100
    }),
    setError: assign({ error: (_, { error }) => error }),
    sendProgress: () => {
    },
    sendError: () => {
    },
    sendDestroy: () => {
    },
    sendDone: () => {
    },
    resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),
    addFile: assign({
      file: (_, { file }) => file,
      bucketId: (_, { bucketId }) => bucketId,
      id: (_, { id }) => id
    })
  },
  services: {
    uploadFile: (context, event) => (callback) => {
      const headers = {
        "Content-Type": "multipart/form-data"
      };
      const fileId = event.id || context.id;
      if (fileId) {
        headers["x-nhost-file-id"] = fileId;
      }
      const bucketId = event.bucketId || context.bucketId;
      if (bucketId) {
        headers["x-nhost-bucket-id"] = bucketId;
      }
      const file = event.file || context.file;
      headers["x-nhost-file-name"] = event.name || file.name;
      const data = new FormData();
      data.append("file", file);
      if (event.adminSecret) {
        headers["x-hasura-admin-secret"] = event.adminSecret;
      }
      if (event.accessToken) {
        headers["Authorization"] = `Bearer ${event.accessToken}`;
      }
      let currentLoaded = 0;
      const controller = new AbortController();
      axios.post(event.url + "/files", data, {
        headers,
        signal: controller.signal,
        onUploadProgress: (event2) => {
          const loaded = Math.round(event2.loaded * file.size / event2.total);
          const additions = loaded - currentLoaded;
          currentLoaded = loaded;
          callback({
            type: "UPLOAD_PROGRESS",
            progress: Math.round(loaded * 100 / event2.total),
            loaded,
            additions
          });
        }
      }).then(({ data: { id, bucketId: bucketId2 } }) => {
        callback({ type: "UPLOAD_DONE", id, bucketId: bucketId2 });
      }).catch(({ response, message }) => {
        var _a, _b, _c, _d, _e;
        callback({
          type: "UPLOAD_ERROR",
          error: {
            status: (_a = response == null ? void 0 : response.status) != null ? _a : 0,
            message: ((_c = (_b = response == null ? void 0 : response.data) == null ? void 0 : _b.error) == null ? void 0 : _c.message) || message,
            error: ((_e = (_d = response == null ? void 0 : response.data) == null ? void 0 : _d.error) == null ? void 0 : _e.message) || message
          }
        });
      });
      return () => {
        controller.abort();
      };
    }
  }
});
const { pure, sendParent } = actions;
const createMultipleFilesUploadMachine = () => {
  return createMachine({
    id: "files-list",
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    context: {
      progress: null,
      files: [],
      loaded: 0,
      total: 0
    },
    initial: "idle",
    on: {
      UPLOAD: { cond: "hasFileToDownload", actions: "addItem", target: "uploading" },
      ADD: { actions: "addItem" },
      REMOVE: { actions: "removeItem" }
    },
    states: {
      idle: {
        entry: ["resetProgress", "resetLoaded", "resetTotal"],
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      uploading: {
        entry: ["upload", "startProgress", "resetLoaded", "resetTotal"],
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress"] },
          UPLOAD_DONE: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          UPLOAD_ERROR: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          CANCEL: { actions: "cancel", target: "idle" }
        }
      },
      uploaded: {
        entry: "setUploaded",
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      error: {
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      }
    }
  }, {
    guards: {
      hasFileToDownload: (context, event) => context.files.some((ref) => ref.getSnapshot().matches("idle")) || !!event.files,
      isAllUploaded: (context) => context.files.every((item) => {
        var _a;
        return (_a = item.getSnapshot()) == null ? void 0 : _a.matches("uploaded");
      }),
      isAllUploadedOrError: (context) => context.files.every((item) => {
        const snap = item.getSnapshot();
        return (snap == null ? void 0 : snap.matches("error")) || (snap == null ? void 0 : snap.matches("uploaded"));
      })
    },
    actions: {
      incrementProgress: assign((context, event) => {
        const loaded = context.loaded + event.additions;
        const progress = Math.round(loaded * 100 / context.total);
        return __spreadProps(__spreadValues({}, context), { loaded, progress });
      }),
      setUploaded: assign({
        progress: (_) => 100,
        loaded: ({ files }) => files.map((ref) => ref.getSnapshot()).filter((snap) => snap.matches("uploaded")).reduce((agg, curr) => {
          var _a;
          return agg + ((_a = curr.context.file) == null ? void 0 : _a.size);
        }, 0)
      }),
      resetTotal: assign({
        total: ({ files }) => files.map((ref) => ref.getSnapshot()).filter((snap) => !snap.matches("uploaded")).reduce((agg, curr) => {
          var _a;
          return agg + ((_a = curr.context.file) == null ? void 0 : _a.size);
        }, 0)
      }),
      resetLoaded: assign({ loaded: (_) => 0 }),
      startProgress: assign({ progress: (_) => 0 }),
      resetProgress: assign({ progress: (_) => null }),
      addItem: assign((context, { files, bucketId }) => {
        const additions = files ? Array.isArray(files) ? files : "length" in files ? Array.from(files) : [files] : [];
        const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0);
        const progress = Math.round(context.loaded * 100 / total);
        return {
          files: [
            ...context.files,
            ...additions.map((file) => spawn(createFileUploadMachine().withConfig({
              actions: {
                sendProgress: sendParent((_, { additions: additions2 }) => ({
                  type: "UPLOAD_PROGRESS",
                  additions: additions2
                })),
                sendDone: sendParent("UPLOAD_DONE"),
                sendError: sendParent("UPLOAD_ERROR"),
                sendDestroy: sendParent("REMOVE")
              }
            }).withContext(__spreadProps(__spreadValues({}, INITIAL_FILE_CONTEXT), { file, bucketId })), { sync: true }))
          ],
          total,
          loaded: context.loaded,
          progress
        };
      }),
      removeItem: assign({
        files: (context) => context.files.filter((ref) => {
          var _a, _b;
          const stopped = (_a = ref.getSnapshot()) == null ? void 0 : _a.matches("stopped");
          if (stopped) {
            (_b = ref.stop) == null ? void 0 : _b.call(ref);
          }
          return !stopped;
        })
      }),
      clearList: pure((context) => context.files.map((ref) => send({ type: "DESTROY" }, { to: ref.id }))),
      upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),
      cancel: pure((context) => context.files.map((ref) => send({ type: "CANCEL" }, { to: ref.id })))
    }
  });
};
const uploadFilePromise = async (nhost, interpreter, params) => new Promise((resolve) => {
  interpreter.send(__spreadValues({
    type: "UPLOAD",
    url: nhost.storage.url,
    accessToken: nhost.auth.getAccessToken(),
    adminSecret: nhost.adminSecret
  }, params));
  interpreter.subscribe((s) => {
    var _a;
    if (s.matches("error")) {
      resolve({
        error: s.context.error,
        isError: true,
        isUploaded: false
      });
    } else if (s.matches("uploaded")) {
      resolve({
        error: null,
        isError: false,
        isUploaded: true,
        id: s.context.id,
        bucketId: s.context.id,
        name: (_a = s.context.file) == null ? void 0 : _a.name
      });
    }
  });
});
const uploadMultipleFilesPromise = async (nhost, service, params) => new Promise((resolve) => {
  service.send({
    type: "UPLOAD",
    url: nhost.storage.url,
    accessToken: nhost.auth.getAccessToken(),
    adminSecret: nhost.adminSecret,
    bucketId: params == null ? void 0 : params.bucketId,
    files: params == null ? void 0 : params.files
  });
  service.onTransition((s) => {
    if (s.matches("error")) {
      resolve({
        errors: s.context.files.filter((ref) => {
          var _a;
          return (_a = ref.getSnapshot()) == null ? void 0 : _a.context.error;
        }),
        isError: true,
        files: []
      });
    } else if (s.matches("uploaded")) {
      resolve({ errors: [], isError: false, files: s.context.files });
    }
  });
});
export { HasuraStorageApi, HasuraStorageClient, INITIAL_FILE_CONTEXT, createFileUploadMachine, createMultipleFilesUploadMachine, uploadFilePromise, uploadMultipleFilesPromise };
//# sourceMappingURL=index.esm.js.map
