{"version":3,"file":"index.esm.js","sources":["../src/hasura-storage-api.ts","../src/hasura-storage-client.ts","../src/machines/file-upload.ts","../src/machines/multiple-files-upload.ts","../src/promises/file-upload.ts","../src/promises/multiple-files-upload.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport axios, { AxiosInstance } from 'axios'\n\nimport {\n  ApiDeleteParams,\n  ApiDeleteResponse,\n  ApiGetPresignedUrlParams,\n  ApiGetPresignedUrlResponse,\n  ApiUploadParams,\n  ApiUploadResponse,\n  UploadHeaders\n} from './utils/types'\n\n/**\n * @internal\n * This is an internal class.\n */\nexport class HasuraStorageApi {\n  private url: string\n  private httpClient: AxiosInstance\n  private accessToken?: string\n  private adminSecret?: string\n\n  constructor({ url }: { url: string }) {\n    this.url = url\n\n    this.httpClient = axios.create({\n      baseURL: this.url\n    })\n  }\n\n  async upload(params: ApiUploadParams): Promise<ApiUploadResponse> {\n    const { formData } = params\n\n    try {\n      const res = await this.httpClient.post('/files', formData, {\n        headers: {\n          ...this.generateUploadHeaders(params),\n          ...this.generateAuthHeaders(),\n          'Content-Type': 'multipart/form-data'\n        }\n      })\n\n      return { fileMetadata: res.data, error: null }\n    } catch (error) {\n      return { fileMetadata: null, error: error as Error }\n    }\n  }\n\n  async getPresignedUrl(params: ApiGetPresignedUrlParams): Promise<ApiGetPresignedUrlResponse> {\n    try {\n      const { fileId } = params\n      const res = await this.httpClient.get(`/files/${fileId}/presignedurl`, {\n        headers: {\n          ...this.generateAuthHeaders()\n        }\n      })\n      return { presignedUrl: res.data, error: null }\n    } catch (error) {\n      return { presignedUrl: null, error: error as Error }\n    }\n  }\n\n  async delete(params: ApiDeleteParams): Promise<ApiDeleteResponse> {\n    try {\n      const { fileId } = params\n      await this.httpClient.delete(`/files/${fileId}`, {\n        headers: {\n          ...this.generateAuthHeaders()\n        }\n      })\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(accessToken?: string): HasuraStorageApi {\n    this.accessToken = accessToken\n\n    return this\n  }\n\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageApi {\n    this.adminSecret = adminSecret\n\n    return this\n  }\n\n  private generateUploadHeaders(params: ApiUploadParams): UploadHeaders {\n    const { bucketId, name, id } = params\n    const uploadheaders: UploadHeaders = {}\n\n    if (bucketId) {\n      uploadheaders['x-nhost-bucket-id'] = bucketId\n    }\n    if (id) {\n      uploadheaders['x-nhost-file-id'] = id\n    }\n    if (name) {\n      uploadheaders['x-nhost-file-name'] = name\n    }\n\n    return uploadheaders\n  }\n\n  private generateAuthHeaders():\n    | { Authorization: string }\n    | { 'x-hasura-admin-secret': string }\n    | null {\n    if (!this.adminSecret && !this.accessToken) {\n      return null\n    }\n\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n\n    return {\n      Authorization: `Bearer ${this.accessToken}`\n    }\n  }\n}\n","import FormData from 'form-data'\n\nimport {\n  StorageDeleteParams,\n  StorageDeleteResponse,\n  StorageGetPresignedUrlParams,\n  StorageGetPresignedUrlResponse,\n  StorageGetUrlParams,\n  StorageUploadFileParams,\n  StorageUploadFormDataParams,\n  StorageUploadParams,\n  StorageUploadResponse\n} from './utils/types'\nimport { HasuraStorageApi } from './hasura-storage-api'\n\ninterface NhostStorageConstructorParams {\n  /**\n   * Storage endpoint.\n   */\n  url: string\n  /**\n   * Admin secret. When set, it is sent as an `x-hasura-admin-secret` header for all requests.\n   */\n  adminSecret?: string\n}\n/**\n * @alias Storage\n */\nexport class HasuraStorageClient {\n  readonly url: string\n  private api: HasuraStorageApi\n\n  constructor({ url, adminSecret }: NhostStorageConstructorParams) {\n    this.url = url\n    this.api = new HasuraStorageApi({ url })\n    this.setAdminSecret(adminSecret)\n  }\n\n  /**\n   * Use `nhost.storage.upload` to upload a file. \n   * \n   * It's possible to use [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) to upload a file. The `File` instance is only available in the browser while `FormData` with [`form-data`](https://www.npmjs.com/package/form-data) works both in the browser and in NodeJS (server).\n   * \n   * If no `bucketId` is specified the bucket `default` is used.\n   *\n   * @example\n   * \n   * Upload a file from a browser using `File`.\n   * \n   * ```ts\n   * await nhost.storage.upload({ file })\n   * ```\n   * \n   * Upload a file from a browser using `File` to a specific Bucket.\n   * \n    @example\n   * ```ts\n   * await nhost.storage.upload({ file, bucketId: '<Bucket-ID>' })\n   * ```\n   * \n   * Upload a file from a server using `FormData` with [`form-data`](https://www.npmjs.com/package/form-data).\n   *\n   * @example\n   * ```ts\n   * const fd = new FormData() \n   * fd.append('file', fs.createReadStream('./tests/assets/sample.pdf'))\n   * \n   * await storage.upload({\n   *   formData: fd\n   * })\n   * ```\n   * \n   * @docs https://docs.nhost.io/reference/javascript/storage/upload\n   */\n\n  async upload(params: StorageUploadFileParams): Promise<StorageUploadResponse>\n  async upload(params: StorageUploadFormDataParams): Promise<StorageUploadResponse>\n  async upload(params: StorageUploadParams): Promise<StorageUploadResponse> {\n    let formData: FormData\n\n    if ('file' in params) {\n      formData = new FormData()\n      formData.append('file', params.file)\n    } else {\n      formData = params.formData\n    }\n\n    const { fileMetadata, error } = await this.api.upload({\n      ...params,\n      formData: formData\n    })\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (!fileMetadata) {\n      return { fileMetadata: null, error: new Error('Invalid file returned') }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  /**\n   * @deprecated Use `nhost.storage.getPublicUrl()` instead.\n   */\n  getUrl(params: StorageGetUrlParams): string {\n    return this.getPublicUrl(params)\n  }\n\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(params: StorageGetUrlParams): string {\n    const { fileId } = params\n    return `${this.url}/files/${fileId}`\n  }\n\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(\n    params: StorageGetPresignedUrlParams\n  ): Promise<StorageGetPresignedUrlResponse> {\n    const { presignedUrl, error } = await this.api.getPresignedUrl(params)\n    if (error) {\n      return { presignedUrl: null, error }\n    }\n\n    if (!presignedUrl) {\n      return { presignedUrl: null, error: new Error('Invalid file id') }\n    }\n\n    return { presignedUrl, error: null }\n  }\n\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(params: StorageDeleteParams): Promise<StorageDeleteResponse> {\n    const { error } = await this.api.delete(params)\n    if (error) {\n      return { error }\n    }\n\n    return { error: null }\n  }\n\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(accessToken?: string): HasuraStorageClient {\n    this.api.setAccessToken(accessToken)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageClient {\n    this.api.setAdminSecret(adminSecret)\n\n    return this\n  }\n}\n","import axios, { AxiosError, AxiosRequestHeaders } from 'axios'\nimport { assign, createMachine } from 'xstate'\n\nimport { ErrorPayload } from '@nhost/core'\n\nexport type FileUploadContext = {\n  progress: number | null\n  loaded: number\n  error: ErrorPayload | null\n  id?: string\n  bucketId?: string\n  file?: File\n}\n\nexport type FileUploadEvents =\n  | { type: 'ADD'; file: File; id?: string; bucketId?: string; name?: string }\n  | {\n      type: 'UPLOAD'\n      url: string\n      file?: File\n      id?: string\n      bucketId?: string\n      name?: string\n      accessToken?: string\n      adminSecret?: string\n    }\n  | { type: 'UPLOAD_PROGRESS'; progress: number; loaded: number; additions: number }\n  | { type: 'UPLOAD_DONE'; id: string; bucketId: string }\n  | { type: 'UPLOAD_ERROR'; error: ErrorPayload }\n  | { type: 'CANCEL' }\n  | { type: 'DESTROY' }\n\nexport const INITIAL_FILE_CONTEXT: FileUploadContext = { progress: null, loaded: 0, error: null }\n\nexport type FileUploadMachine = ReturnType<typeof createFileUploadMachine>\nexport const createFileUploadMachine = () =>\n  createMachine(\n    {\n      preserveActionOrder: true,\n      schema: {\n        context: {} as FileUploadContext,\n        events: {} as FileUploadEvents\n      },\n      tsTypes: {} as import('./file-upload.typegen').Typegen0,\n      context: { ...INITIAL_FILE_CONTEXT },\n      initial: 'idle',\n      on: {\n        DESTROY: { actions: 'sendDestroy', target: 'stopped' }\n      },\n      states: {\n        idle: {\n          on: {\n            ADD: { actions: 'addFile' },\n            UPLOAD: { cond: 'hasFile', target: 'uploading' }\n          }\n        },\n        uploading: {\n          entry: 'resetProgress',\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress', 'sendProgress'] },\n            UPLOAD_DONE: 'uploaded',\n            UPLOAD_ERROR: 'error',\n            CANCEL: 'idle'\n          },\n          invoke: { src: 'uploadFile' }\n        },\n        uploaded: { entry: ['setFileMetadata', 'sendDone'] },\n        error: { entry: ['setError', 'sendError'] },\n        stopped: { type: 'final' }\n      }\n    },\n    {\n      guards: {\n        hasFile: (context, event) => !!context.file || !!event.file\n      },\n\n      actions: {\n        incrementProgress: assign({\n          loaded: (_, { loaded }) => loaded,\n          progress: (_, { progress }) => progress\n        }),\n        setFileMetadata: assign({\n          id: (_, { id }) => id,\n          bucketId: (_, { bucketId }) => bucketId,\n          progress: (_) => 100\n        }),\n        setError: assign({ error: (_, { error }) => error }),\n        sendProgress: () => {},\n        sendError: () => {},\n        sendDestroy: () => {},\n        sendDone: () => {},\n        resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),\n        addFile: assign({\n          file: (_, { file }) => file,\n          bucketId: (_, { bucketId }) => bucketId,\n          id: (_, { id }) => id\n        })\n      },\n      services: {\n        uploadFile: (context, event) => (callback) => {\n          const headers: AxiosRequestHeaders = {\n            'Content-Type': 'multipart/form-data'\n          }\n          const fileId = event.id || context.id\n          if (fileId) {\n            headers['x-nhost-file-id'] = fileId\n          }\n          const bucketId = event.bucketId || context.bucketId\n          if (bucketId) {\n            headers['x-nhost-bucket-id'] = bucketId\n          }\n          const file = (event.file || context.file)!\n          headers['x-nhost-file-name'] = event.name || file.name\n          const data = new FormData()\n          data.append('file', file)\n          if (event.adminSecret) {\n            headers['x-hasura-admin-secret'] = event.adminSecret\n          }\n          if (event.accessToken) {\n            headers['Authorization'] = `Bearer ${event.accessToken}`\n          }\n          let currentLoaded = 0\n          const controller = new AbortController()\n          axios\n            .post<{\n              bucketId: string\n              createdAt: string\n              etag: string\n              id: string\n              isUploaded: true\n              mimeType: string\n              name: string\n              size: number\n              updatedAt: string\n              uploadedByUserId: string\n            }>(event.url + '/files', data, {\n              headers,\n              signal: controller.signal,\n              onUploadProgress: (event: ProgressEvent) => {\n                const loaded = Math.round((event.loaded * file.size!) / event.total)\n                const additions = loaded - currentLoaded\n                currentLoaded = loaded\n                callback({\n                  type: 'UPLOAD_PROGRESS',\n                  progress: Math.round((loaded * 100) / event.total),\n                  loaded,\n                  additions\n                })\n              }\n            })\n            .then(({ data: { id, bucketId } }) => {\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            })\n            .catch(({ response, message }: AxiosError<{ error?: { message: string } }>) => {\n              callback({\n                type: 'UPLOAD_ERROR',\n                error: {\n                  status: response?.status ?? 0,\n                  message: response?.data?.error?.message || message,\n                  // TODO errors from hasura-storage are not codified\n                  error: response?.data?.error?.message || message\n                }\n              })\n            })\n\n          return () => {\n            controller.abort()\n          }\n        }\n      }\n    }\n  )\n","import { actions, ActorRefFrom, assign, createMachine, send, spawn } from 'xstate'\n\nimport { createFileUploadMachine, FileUploadMachine, INITIAL_FILE_CONTEXT } from './file-upload'\n\nconst { pure, sendParent } = actions\n\nexport type FileItemRef = ActorRefFrom<FileUploadMachine>\n\nexport type AnyFileList = File | File[] | FileList\n\nexport type MultipleFilesUploadContext = {\n  progress: number | null\n  files: FileItemRef[]\n  loaded: number\n  total: number\n}\n\nexport type MultipleFilesUploadEvents =\n  | { type: 'ADD'; files: AnyFileList; bucketId?: string }\n  | {\n      type: 'UPLOAD'\n      url: string\n      files?: AnyFileList\n      bucketId?: string\n      accessToken?: string\n      adminSecret?: string\n    }\n  | { type: 'UPLOAD_PROGRESS'; additions: number }\n  | { type: 'UPLOAD_DONE' }\n  | { type: 'UPLOAD_ERROR' }\n  | { type: 'CANCEL' }\n  | { type: 'REMOVE' }\n  | { type: 'CLEAR' }\n\nexport type MultipleFilesUploadMachine = ReturnType<typeof createMultipleFilesUploadMachine>\n\nexport const createMultipleFilesUploadMachine = () => {\n  return createMachine(\n    {\n      id: 'files-list',\n      schema: {\n        context: {} as MultipleFilesUploadContext,\n        events: {} as MultipleFilesUploadEvents\n      },\n      tsTypes: {} as import('./multiple-files-upload.typegen').Typegen0,\n      context: {\n        progress: null,\n        files: [],\n        loaded: 0,\n        total: 0\n      },\n      initial: 'idle',\n      on: {\n        UPLOAD: { cond: 'hasFileToDownload', actions: 'addItem', target: 'uploading' },\n        ADD: { actions: 'addItem' },\n        REMOVE: { actions: 'removeItem' }\n      },\n      states: {\n        idle: {\n          entry: ['resetProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        uploading: {\n          entry: ['upload', 'startProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress'] },\n            UPLOAD_DONE: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            UPLOAD_ERROR: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            CANCEL: { actions: 'cancel', target: 'idle' }\n          }\n        },\n        uploaded: {\n          entry: 'setUploaded',\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        error: {\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        hasFileToDownload: (context, event) =>\n          context.files.some((ref) => ref.getSnapshot()!.matches('idle')) || !!event.files,\n        isAllUploaded: (context) =>\n          context.files.every((item) => item.getSnapshot()?.matches('uploaded')),\n        isAllUploadedOrError: (context) =>\n          context.files.every((item) => {\n            const snap = item.getSnapshot()\n            return snap?.matches('error') || snap?.matches('uploaded')\n          })\n      },\n\n      actions: {\n        incrementProgress: assign((context, event) => {\n          const loaded: number = context.loaded + event.additions\n          const progress = Math.round((loaded * 100) / context.total)\n          return { ...context, loaded, progress }\n        }),\n        setUploaded: assign({\n          progress: (_) => 100,\n          loaded: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetTotal: assign({\n          total: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => !snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetLoaded: assign({ loaded: (_) => 0 }),\n        startProgress: assign({ progress: (_) => 0 }),\n        resetProgress: assign({ progress: (_) => null }),\n        addItem: assign((context, { files, bucketId }) => {\n          const additions = files\n            ? Array.isArray(files)\n              ? files // File[]\n              : 'length' in files // FileList\n              ? Array.from(files)\n              : [files] // File\n            : [] // No file\n          const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0)\n          const progress = Math.round((context.loaded * 100) / total)\n          return {\n            files: [\n              ...context.files,\n              ...additions.map((file) =>\n                spawn(\n                  createFileUploadMachine()\n                    .withConfig({\n                      actions: {\n                        sendProgress: sendParent((_, { additions }) => ({\n                          type: 'UPLOAD_PROGRESS',\n                          additions\n                        })),\n                        sendDone: sendParent('UPLOAD_DONE'),\n                        sendError: sendParent('UPLOAD_ERROR'),\n                        sendDestroy: sendParent('REMOVE')\n                      }\n                    })\n                    .withContext({ ...INITIAL_FILE_CONTEXT, file, bucketId }),\n                  { sync: true }\n                )\n              )\n            ],\n            total,\n            loaded: context.loaded,\n            progress\n          }\n        }),\n        removeItem: assign({\n          files: (context) =>\n            context.files.filter((ref) => {\n              const stopped = ref.getSnapshot()?.matches('stopped')\n              if (stopped) {\n                ref.stop?.()\n              }\n              return !stopped\n            })\n        }),\n        clearList: pure((context) =>\n          context.files.map((ref) => send({ type: 'DESTROY' }, { to: ref.id }))\n        ),\n        upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),\n        cancel: pure((context) =>\n          context.files.map((ref) => send({ type: 'CANCEL' }, { to: ref.id }))\n        )\n      }\n    }\n  )\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ActionErrorState } from '@nhost/core'\n\nimport { FileItemRef, FileUploadMachine } from '../machines'\nimport { NhostClientReturnType, StorageUploadFileParams } from '../utils/types'\n\nexport interface UploadProgressState {\n  /**\n   * Returns `true` when the file is being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface UploadFileHandlerResult extends ActionErrorState {\n  /**\n   * Returns `true` when the file has been successfully uploaded.\n   */\n  isUploaded: boolean\n  /**\n   * Returns the id of the file.\n   */\n  id?: string\n  /**\n   * Returns the bucket id.\n   */\n  bucketId?: string\n  /**\n   * Returns the name of the file.\n   */\n  name?: string\n}\n\nexport interface FileUploadState extends UploadFileHandlerResult, UploadProgressState {}\n\nexport const uploadFilePromise = async (\n  nhost: NhostClientReturnType,\n  interpreter: FileItemRef | InterpreterFrom<FileUploadMachine>,\n  params: Partial<StorageUploadFileParams>\n): Promise<UploadFileHandlerResult> =>\n  new Promise<UploadFileHandlerResult>((resolve) => {\n    interpreter.send({\n      type: 'UPLOAD',\n      url: nhost.storage.url,\n      accessToken: nhost.auth.getAccessToken(),\n      adminSecret: nhost.adminSecret,\n      ...params\n    })\n    interpreter.subscribe((s) => {\n      if (s.matches('error')) {\n        resolve({\n          error: s.context.error,\n          isError: true,\n          isUploaded: false\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({\n          error: null,\n          isError: false,\n          isUploaded: true,\n          id: s.context.id,\n          bucketId: s.context.id,\n          name: s.context.file?.name\n        })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { AnyFileList, FileItemRef, MultipleFilesUploadMachine } from '../machines'\nimport { NhostClientReturnType } from '../utils/types'\n\nexport interface MultipleUploadProgressState {\n  /**\n   * Returns `true` when the files are being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the overall progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface MultipleFilesHandlerResult {\n  /**\n   * The list of file uploads. The properties can be accessed through `item.getSnapshot()` of with the `useFileUploadItem` hook.\n   */\n  files: FileItemRef[]\n  /**\n   * Returns `true` when all upload request are processed, but at least one of them has failed.\n   */\n  isError: boolean\n  /**\n   * Returns the list of file uploads that have failed\n   */\n  errors: FileItemRef[]\n}\n\nexport interface MultipleFilesUploadState\n  extends MultipleFilesHandlerResult,\n    MultipleUploadProgressState {\n  /**\n   * Returns `true` when all the files have been successfully uploaded.\n   */\n  isUploaded: boolean\n}\n\nexport type UploadMultipleFilesActionParams = {\n  files?: AnyFileList\n  bucketId?: string\n}\n\nexport const uploadMultipleFilesPromise = async (\n  nhost: NhostClientReturnType,\n  service: InterpreterFrom<MultipleFilesUploadMachine>,\n  params?: UploadMultipleFilesActionParams\n): Promise<MultipleFilesHandlerResult> =>\n  new Promise((resolve) => {\n    service.send({\n      type: 'UPLOAD',\n      url: nhost.storage.url,\n      accessToken: nhost.auth.getAccessToken(),\n      adminSecret: nhost.adminSecret,\n      bucketId: params?.bucketId,\n      files: params?.files\n    })\n    service.onTransition((s) => {\n      if (s.matches('error')) {\n        resolve({\n          errors: s.context.files.filter((ref) => ref.getSnapshot()?.context.error),\n          isError: true,\n          files: []\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({ errors: [], isError: false, files: s.context.files })\n      }\n    })\n  })\n"],"names":["FormData"],"mappings":"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"}