{"version":3,"file":"index.esm.js","sources":["../src/utils/helpers.ts","../src/hasura-auth-client.ts"],"sourcesContent":["import { AuthContext, NhostSession, SessionActionHandlerResult, SignUpResponse } from '@nhost/core'\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\n\nimport {\n  addSecurityKeyPromise,\n  AuthClient,\n  AuthInterpreter,\n  changeEmailPromise,\n  ChangeEmailResponse,\n  changePasswordPromise,\n  ChangePasswordResponse,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine,\n  DeanonymizeResponse,\n  EMAIL_NEEDS_VERIFICATION,\n  encodeQueryParameters,\n  ErrorPayload,\n  INVALID_REFRESH_TOKEN,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostSessionResponse,\n  NO_REFRESH_TOKEN,\n  resetPasswordPromise,\n  ResetPasswordResponse,\n  rewriteRedirectTo,\n  SecurityKey,\n  sendVerificationEmailPromise,\n  SendVerificationEmailResponse,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  SignInResponse,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  SignOutResponse,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  SignUpResponse,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from '@nhost/core'\n\nimport { getAuthenticationResult, getSession, isBrowser } from './utils/helpers'\nimport {\n  AuthChangedFunction,\n  ChangeEmailParams,\n  ChangePasswordParams,\n  DeanonymizeParams,\n  NhostAuthConstructorParams,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  SendVerificationEmailParams,\n  SignInParams,\n  SignUpParams\n} from './utils/types'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    autoLogin,\n    clientStorage,\n    clientStorageType,\n    clientStorageGetter,\n    clientStorageSetter,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === 'boolean' ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n    // * Anonymous sign-in\n    const anonymousResult = await signInAnonymousPromise(interpreter)\n    return { ...getAuthenticationResult(anonymousResult), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: ErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n  } {\n    if (!this.isReady()) {\n      return { isAuthenticated: false, isLoading: true }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false }\n  }\n\n  /**\n   * @internal\n   * @deprecated Use `nhost.auth.getAccessToken()` instead.\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n\n  getJWTToken(): string | undefined {\n    return this.getAccessToken()\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.state.context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.state.context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.state?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.state?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.state.hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.state?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":[],"mappings":"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"}