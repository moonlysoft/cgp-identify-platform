"use strict";var E=Object.defineProperty,p=Object.defineProperties;var P=Object.getOwnPropertyDescriptors;var f=Object.getOwnPropertySymbols;var I=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var g=(i,e,t)=>e in i?E(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,l=(i,e)=>{for(var t in e||(e={}))I.call(e,t)&&g(i,t,e[t]);if(f)for(var t of f(e))S.call(e,t)&&g(i,t,e[t]);return i},u=(i,e)=>p(i,P(e));Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});var N=require("jwt-decode"),d=require("xstate"),s=require("@nhost/core");function k(i){return i&&typeof i=="object"&&"default"in i?i:{default:i}}var A=k(N);const R=()=>typeof window!="undefined",h=i=>!i||!i.accessToken.value||!i.refreshToken.value||!i.accessToken.expiresAt||!i.user?null:{accessToken:i.accessToken.value,accessTokenExpiresIn:(i.accessToken.expiresAt.getTime()-Date.now())/1e3,refreshToken:i.refreshToken.value,user:i.user},c=({accessToken:i,isError:e,user:t,error:n})=>e?{session:null,error:n}:t&&i?{session:{accessToken:i,accessTokenExpiresIn:0,refreshToken:"",user:t},error:null}:{session:null,error:null};class U{constructor({url:e,autoRefreshToken:t=!0,autoSignIn:n=!0,autoLogin:r,clientStorage:o,clientStorageType:a,clientStorageGetter:y,clientStorageSetter:T,refreshIntervalTime:m,start:_=!0}){var w;this.url=e,this._client=new s.AuthClient({backendUrl:e,clientUrl:typeof window!="undefined"&&((w=window.location)==null?void 0:w.origin)||"",autoRefreshToken:t,autoSignIn:typeof r=="boolean"?r:n,start:_,clientStorage:o,clientStorageType:a,clientStorageGetter:y,clientStorageSetter:T,refreshIntervalTime:m})}async signUp(e){const t=await this.waitUntilReady(),{email:n,options:r}=e;return"securityKey"in e?c(await s.signUpEmailSecurityKeyPromise(t,n,r)):c(await s.signUpEmailPasswordPromise(t,n,e.password,r))}async signIn(e){const t=await this.waitUntilReady();if("provider"in e){const{provider:r,options:o}=e,a=s.encodeQueryParameters(`${this._client.backendUrl}/signin/provider/${r}`,s.rewriteRedirectTo(this._client.clientUrl,o));return R()&&(window.location.href=a),{providerUrl:a,provider:r,session:null,mfa:null,error:null}}if("email"in e&&"password"in e){const r=await s.signInEmailPasswordPromise(t,e.email,e.password);return r.needsEmailVerification?{session:null,mfa:null,error:s.EMAIL_NEEDS_VERIFICATION}:r.needsMfaOtp?{session:null,mfa:r.mfa,error:null}:u(l({},c(r)),{mfa:null})}if("email"in e&&"securityKey"in e){if(e.securityKey!==!0)throw Error("securityKey must be true");const r=await s.signInEmailSecurityKeyPromise(t,e.email);return u(l({},c(r)),{mfa:null})}if("email"in e){const{email:r,options:o}=e,{error:a}=await s.signInEmailPasswordlessPromise(t,r,o);return{session:null,mfa:null,error:a}}if("phoneNumber"in e&&"otp"in e){const r=await s.signInSmsPasswordlessOtpPromise(t,e.phoneNumber,e.otp);return u(l({},c(r)),{mfa:null})}if("phoneNumber"in e){const{error:r}=await s.signInSmsPasswordlessPromise(t,e.phoneNumber,e.options);return{error:r,mfa:null,session:null}}if("otp"in e){const r=await s.signInMfaTotpPromise(t,e.otp,e.ticket);return u(l({},c(r)),{mfa:null})}const n=await s.signInAnonymousPromise(t);return u(l({},c(n)),{mfa:null})}async signOut(e){const t=await this.waitUntilReady(),{error:n}=await s.signOutPromise(t,e==null?void 0:e.all);return{error:n}}async resetPassword({email:e,options:t}){const n=d.interpret(s.createResetPasswordMachine(this._client)).start(),{error:r}=await s.resetPasswordPromise(n,e,t);return{error:r}}async changePassword({newPassword:e,ticket:t}){const n=d.interpret(s.createChangePasswordMachine(this._client)).start(),{error:r}=await s.changePasswordPromise(n,e,t);return{error:r}}async sendVerificationEmail({email:e,options:t}){const n=d.interpret(s.createSendVerificationEmailMachine(this._client)).start(),{error:r}=await s.sendVerificationEmailPromise(n,e,t);return{error:r}}async changeEmail({newEmail:e,options:t}){const n=d.interpret(s.createChangeEmailMachine(this._client)).start(),{error:r}=await s.changeEmailPromise(n,e,t);return{error:r}}async deanonymize(e){const t=await this.waitUntilReady();if(e.signInMethod==="passwordless"){if(e.connection==="email"){const{error:n}=await s.signInEmailPasswordlessPromise(t,e.email,e.options);return{error:n}}if(e.connection==="sms"){const{error:n}=await s.signInSmsPasswordlessPromise(t,e.phoneNumber,e.options);return{error:n}}}if(e.signInMethod==="email-password"){const{error:n}=await s.signUpEmailPasswordPromise(t,e.email,e.password,e.options);return{error:n}}throw Error("Unknown deanonymization method")}async addSecurityKey(e){const{error:t,key:n}=await s.addSecurityKeyPromise(this._client,e);return{error:t,key:n}}onTokenChanged(e){const t=n=>n.onTransition(({event:r,context:o})=>{r.type==="TOKEN_CHANGED"&&e(h(o))});if(this._client.interpreter){const n=t(this._client.interpreter);return()=>n.stop()}else return this._client.onStart(n=>{t(n.interpreter)}),()=>{console.log("onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.")}}onAuthStateChanged(e){const t=n=>n.onTransition(({event:r,context:o})=>{(r.type==="SIGNED_IN"||r.type==="SIGNED_OUT")&&e(r.type,h(o))});if(this._client.interpreter){const n=t(this._client.interpreter);return()=>n.stop()}else return this._client.onStart(n=>{t(n.interpreter)}),()=>{console.log("onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.")}}isAuthenticated(){var e;return!!((e=this._client.interpreter)!=null&&e.state.matches({authentication:"signedIn"}))}async isAuthenticatedAsync(){return(await this.waitUntilReady()).state.matches({authentication:"signedIn"})}getAuthenticationStatus(){return this.isReady()?{isAuthenticated:this.isAuthenticated(),isLoading:!1}:{isAuthenticated:!1,isLoading:!0}}getJWTToken(){return this.getAccessToken()}getAccessToken(){var e,t;return(t=(e=this._client.interpreter)==null?void 0:e.state.context.accessToken.value)!=null?t:void 0}getDecodedAccessToken(){const e=this.getAccessToken();return e?A.default(e):null}getHasuraClaims(){var e;return((e=this.getDecodedAccessToken())==null?void 0:e["https://hasura.io/jwt/claims"])||null}getHasuraClaim(e){var t;return((t=this.getHasuraClaims())==null?void 0:t[e.startsWith("x-hasura-")?e:`x-hasura-${e}`])||null}async refreshSession(e){try{const t=await this.waitUntilReady();return new Promise(n=>{const r=e||t.state.context.refreshToken.value;if(!r)return n({session:null,error:s.NO_REFRESH_TOKEN});const{changed:o}=t.send("TRY_TOKEN",{token:r});if(!o)return n({session:null,error:s.TOKEN_REFRESHER_RUNNING_ERROR});t.onTransition(a=>{a.matches({token:{idle:"error"}})?n({session:null,error:s.INVALID_REFRESH_TOKEN}):a.event.type==="TOKEN_CHANGED"&&n({session:h(a.context),error:null})})})}catch(t){return{session:null,error:t.message}}}getSession(){var e,t;return h((t=(e=this._client.interpreter)==null?void 0:e.state)==null?void 0:t.context)}getUser(){var e,t,n;return((n=(t=(e=this._client.interpreter)==null?void 0:e.state)==null?void 0:t.context)==null?void 0:n.user)||null}waitUntilReady(){const t=this._client.interpreter;if(!t)throw Error("Auth interpreter not set");return t.state.hasTag("loading")?new Promise((n,r)=>{let o=setTimeout(()=>r(`The state machine is not yet ready after ${15} seconds.`),15e3);t.onTransition(a=>{if(!a.hasTag("loading"))return clearTimeout(o),n(t)})}):Promise.resolve(t)}isReady(){var e,t;return!((t=(e=this._client.interpreter)==null?void 0:e.state)!=null&&t.hasTag("loading"))}get client(){return this._client}}exports.HasuraAuthClient=U;
//# sourceMappingURL=index.cjs.js.map
