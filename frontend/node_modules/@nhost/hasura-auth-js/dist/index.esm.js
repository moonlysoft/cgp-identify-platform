var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import jwt_decode from "jwt-decode";
import { interpret } from "xstate";
import { AuthClient, signUpEmailSecurityKeyPromise, signUpEmailPasswordPromise, encodeQueryParameters, rewriteRedirectTo, signInEmailPasswordPromise, EMAIL_NEEDS_VERIFICATION, signInEmailSecurityKeyPromise, signInEmailPasswordlessPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signInMfaTotpPromise, signInAnonymousPromise, signOutPromise, createResetPasswordMachine, resetPasswordPromise, createChangePasswordMachine, changePasswordPromise, createSendVerificationEmailMachine, sendVerificationEmailPromise, createChangeEmailMachine, changeEmailPromise, addSecurityKeyPromise, NO_REFRESH_TOKEN, TOKEN_REFRESHER_RUNNING_ERROR, INVALID_REFRESH_TOKEN } from "@nhost/core";
const isBrowser = () => typeof window !== "undefined";
const getSession = (context) => {
  if (!context || !context.accessToken.value || !context.refreshToken.value || !context.accessToken.expiresAt || !context.user) {
    return null;
  }
  return {
    accessToken: context.accessToken.value,
    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
    refreshToken: context.refreshToken.value,
    user: context.user
  };
};
const getAuthenticationResult = ({
  accessToken,
  isError,
  user,
  error
}) => {
  if (isError) {
    return {
      session: null,
      error
    };
  }
  if (user && accessToken) {
    return {
      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: "", user },
      error: null
    };
  }
  return { session: null, error: null };
};
class HasuraAuthClient {
  constructor({
    url,
    autoRefreshToken = true,
    autoSignIn = true,
    autoLogin,
    clientStorage,
    clientStorageType,
    clientStorageGetter,
    clientStorageSetter,
    refreshIntervalTime,
    start = true
  }) {
    var _a;
    this.url = url;
    this._client = new AuthClient({
      backendUrl: url,
      clientUrl: typeof window !== "undefined" && ((_a = window.location) == null ? void 0 : _a.origin) || "",
      autoRefreshToken,
      autoSignIn: typeof autoLogin === "boolean" ? autoLogin : autoSignIn,
      start,
      clientStorage,
      clientStorageType,
      clientStorageGetter,
      clientStorageSetter,
      refreshIntervalTime
    });
  }
  async signUp(params) {
    const interpreter = await this.waitUntilReady();
    const { email, options } = params;
    if ("securityKey" in params) {
      return getAuthenticationResult(await signUpEmailSecurityKeyPromise(interpreter, email, options));
    }
    return getAuthenticationResult(await signUpEmailPasswordPromise(interpreter, email, params.password, options));
  }
  async signIn(params) {
    const interpreter = await this.waitUntilReady();
    if ("provider" in params) {
      const { provider, options } = params;
      const providerUrl = encodeQueryParameters(`${this._client.backendUrl}/signin/provider/${provider}`, rewriteRedirectTo(this._client.clientUrl, options));
      if (isBrowser()) {
        window.location.href = providerUrl;
      }
      return { providerUrl, provider, session: null, mfa: null, error: null };
    }
    if ("email" in params && "password" in params) {
      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password);
      if (res.needsEmailVerification) {
        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION };
      }
      if (res.needsMfaOtp) {
        return {
          session: null,
          mfa: res.mfa,
          error: null
        };
      }
      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), { mfa: null });
    }
    if ("email" in params && "securityKey" in params) {
      if (params.securityKey !== true) {
        throw Error("securityKey must be true");
      }
      const res = await signInEmailSecurityKeyPromise(interpreter, params.email);
      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), { mfa: null });
    }
    if ("email" in params) {
      const { email, options } = params;
      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options);
      return {
        session: null,
        mfa: null,
        error
      };
    }
    if ("phoneNumber" in params && "otp" in params) {
      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp);
      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), { mfa: null });
    }
    if ("phoneNumber" in params) {
      const { error } = await signInSmsPasswordlessPromise(interpreter, params.phoneNumber, params.options);
      return { error, mfa: null, session: null };
    }
    if ("otp" in params) {
      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket);
      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), { mfa: null });
    }
    const anonymousResult = await signInAnonymousPromise(interpreter);
    return __spreadProps(__spreadValues({}, getAuthenticationResult(anonymousResult)), { mfa: null });
  }
  async signOut(params) {
    const interpreter = await this.waitUntilReady();
    const { error } = await signOutPromise(interpreter, params == null ? void 0 : params.all);
    return { error };
  }
  async resetPassword({ email, options }) {
    const service = interpret(createResetPasswordMachine(this._client)).start();
    const { error } = await resetPasswordPromise(service, email, options);
    return { error };
  }
  async changePassword({
    newPassword,
    ticket
  }) {
    const service = interpret(createChangePasswordMachine(this._client)).start();
    const { error } = await changePasswordPromise(service, newPassword, ticket);
    return { error };
  }
  async sendVerificationEmail({
    email,
    options
  }) {
    const service = interpret(createSendVerificationEmailMachine(this._client)).start();
    const { error } = await sendVerificationEmailPromise(service, email, options);
    return { error };
  }
  async changeEmail({ newEmail, options }) {
    const service = interpret(createChangeEmailMachine(this._client)).start();
    const { error } = await changeEmailPromise(service, newEmail, options);
    return { error };
  }
  async deanonymize(params) {
    const interpreter = await this.waitUntilReady();
    if (params.signInMethod === "passwordless") {
      if (params.connection === "email") {
        const { error } = await signInEmailPasswordlessPromise(interpreter, params.email, params.options);
        return { error };
      }
      if (params.connection === "sms") {
        const { error } = await signInSmsPasswordlessPromise(interpreter, params.phoneNumber, params.options);
        return { error };
      }
    }
    if (params.signInMethod === "email-password") {
      const { error } = await signUpEmailPasswordPromise(interpreter, params.email, params.password, params.options);
      return { error };
    }
    throw Error(`Unknown deanonymization method`);
  }
  async addSecurityKey(nickname) {
    const { error, key } = await addSecurityKeyPromise(this._client, nickname);
    return { error, key };
  }
  onTokenChanged(fn) {
    const listen = (interpreter) => interpreter.onTransition(({ event, context }) => {
      if (event.type === "TOKEN_CHANGED") {
        fn(getSession(context));
      }
    });
    if (this._client.interpreter) {
      const subscription = listen(this._client.interpreter);
      return () => subscription.stop();
    } else {
      this._client.onStart((client) => {
        listen(client.interpreter);
      });
      return () => {
        console.log("onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.");
      };
    }
  }
  onAuthStateChanged(fn) {
    const listen = (interpreter) => interpreter.onTransition(({ event, context }) => {
      if (event.type === "SIGNED_IN" || event.type === "SIGNED_OUT") {
        fn(event.type, getSession(context));
      }
    });
    if (this._client.interpreter) {
      const subscription = listen(this._client.interpreter);
      return () => subscription.stop();
    } else {
      this._client.onStart((client) => {
        listen(client.interpreter);
      });
      return () => {
        console.log("onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.");
      };
    }
  }
  isAuthenticated() {
    var _a;
    return !!((_a = this._client.interpreter) == null ? void 0 : _a.state.matches({ authentication: "signedIn" }));
  }
  async isAuthenticatedAsync() {
    const interpreter = await this.waitUntilReady();
    return interpreter.state.matches({ authentication: "signedIn" });
  }
  getAuthenticationStatus() {
    if (!this.isReady()) {
      return { isAuthenticated: false, isLoading: true };
    }
    return { isAuthenticated: this.isAuthenticated(), isLoading: false };
  }
  getJWTToken() {
    return this.getAccessToken();
  }
  getAccessToken() {
    var _a, _b;
    return (_b = (_a = this._client.interpreter) == null ? void 0 : _a.state.context.accessToken.value) != null ? _b : void 0;
  }
  getDecodedAccessToken() {
    const jwt = this.getAccessToken();
    if (!jwt)
      return null;
    return jwt_decode(jwt);
  }
  getHasuraClaims() {
    var _a;
    return ((_a = this.getDecodedAccessToken()) == null ? void 0 : _a["https://hasura.io/jwt/claims"]) || null;
  }
  getHasuraClaim(name) {
    var _a;
    return ((_a = this.getHasuraClaims()) == null ? void 0 : _a[name.startsWith("x-hasura-") ? name : `x-hasura-${name}`]) || null;
  }
  async refreshSession(refreshToken) {
    try {
      const interpreter = await this.waitUntilReady();
      return new Promise((resolve) => {
        const token = refreshToken || interpreter.state.context.refreshToken.value;
        if (!token) {
          return resolve({ session: null, error: NO_REFRESH_TOKEN });
        }
        const { changed } = interpreter.send("TRY_TOKEN", { token });
        if (!changed) {
          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR });
        }
        interpreter.onTransition((state) => {
          if (state.matches({ token: { idle: "error" } })) {
            resolve({
              session: null,
              error: INVALID_REFRESH_TOKEN
            });
          } else if (state.event.type === "TOKEN_CHANGED") {
            resolve({ session: getSession(state.context), error: null });
          }
        });
      });
    } catch (error) {
      return { session: null, error: error.message };
    }
  }
  getSession() {
    var _a, _b;
    return getSession((_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.context);
  }
  getUser() {
    var _a, _b, _c;
    return ((_c = (_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.context) == null ? void 0 : _c.user) || null;
  }
  waitUntilReady() {
    const TIMEOUT_IN_SECONS = 15;
    const interpreter = this._client.interpreter;
    if (!interpreter) {
      throw Error("Auth interpreter not set");
    }
    if (!interpreter.state.hasTag("loading")) {
      return Promise.resolve(interpreter);
    }
    return new Promise((resolve, reject) => {
      let timer = setTimeout(() => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`), TIMEOUT_IN_SECONS * 1e3);
      interpreter.onTransition((state) => {
        if (!state.hasTag("loading")) {
          clearTimeout(timer);
          return resolve(interpreter);
        }
      });
    });
  }
  isReady() {
    var _a, _b;
    return !((_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.hasTag("loading"));
  }
  get client() {
    return this._client;
  }
}
export { HasuraAuthClient };
//# sourceMappingURL=index.esm.js.map
