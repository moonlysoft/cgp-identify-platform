{"version":3,"file":"index.cjs.js","sources":["../src/utils/helpers.ts","../src/hasura-auth-client.ts"],"sourcesContent":["import { AuthContext, NhostSession, SessionActionHandlerResult, SignUpResponse } from '@nhost/core'\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\n\nimport {\n  addSecurityKeyPromise,\n  AuthClient,\n  AuthInterpreter,\n  changeEmailPromise,\n  ChangeEmailResponse,\n  changePasswordPromise,\n  ChangePasswordResponse,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine,\n  DeanonymizeResponse,\n  EMAIL_NEEDS_VERIFICATION,\n  encodeQueryParameters,\n  ErrorPayload,\n  INVALID_REFRESH_TOKEN,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostSessionResponse,\n  NO_REFRESH_TOKEN,\n  resetPasswordPromise,\n  ResetPasswordResponse,\n  rewriteRedirectTo,\n  SecurityKey,\n  sendVerificationEmailPromise,\n  SendVerificationEmailResponse,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  SignInResponse,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  SignOutResponse,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  SignUpResponse,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from '@nhost/core'\n\nimport { getAuthenticationResult, getSession, isBrowser } from './utils/helpers'\nimport {\n  AuthChangedFunction,\n  ChangeEmailParams,\n  ChangePasswordParams,\n  DeanonymizeParams,\n  NhostAuthConstructorParams,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  SendVerificationEmailParams,\n  SignInParams,\n  SignUpParams\n} from './utils/types'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    autoLogin,\n    clientStorage,\n    clientStorageType,\n    clientStorageGetter,\n    clientStorageSetter,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === 'boolean' ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n    // * Anonymous sign-in\n    const anonymousResult = await signInAnonymousPromise(interpreter)\n    return { ...getAuthenticationResult(anonymousResult), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: ErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n  } {\n    if (!this.isReady()) {\n      return { isAuthenticated: false, isLoading: true }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false }\n  }\n\n  /**\n   * @internal\n   * @deprecated Use `nhost.auth.getAccessToken()` instead.\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n\n  getJWTToken(): string | undefined {\n    return this.getAccessToken()\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.state.context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.state.context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.state?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.state?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.state.hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.state?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":["AuthClient","signUpEmailSecurityKeyPromise","signUpEmailPasswordPromise","encodeQueryParameters","rewriteRedirectTo","signInEmailPasswordPromise","EMAIL_NEEDS_VERIFICATION","signInEmailSecurityKeyPromise","signInEmailPasswordlessPromise","signInSmsPasswordlessOtpPromise","signInSmsPasswordlessPromise","signInMfaTotpPromise","signInAnonymousPromise","signOutPromise","interpret","createResetPasswordMachine","resetPasswordPromise","createChangePasswordMachine","changePasswordPromise","createSendVerificationEmailMachine","sendVerificationEmailPromise","createChangeEmailMachine","changeEmailPromise","addSecurityKeyPromise","jwt_decode","NO_REFRESH_TOKEN","TOKEN_REFRESHER_RUNNING_ERROR","INVALID_REFRESH_TOKEN"],"mappings":"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"}