var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { HasuraAuthClient } from "@nhost/hasura-auth-js";
import { HasuraStorageClient } from "@nhost/hasura-storage-js";
import axios from "axios";
import { print } from "graphql";
class NhostFunctionsClient {
  constructor(params) {
    const { url, adminSecret } = params;
    this.accessToken = null;
    this.adminSecret = adminSecret;
    this.instance = axios.create({
      baseURL: url
    });
  }
  async call(url, data, config) {
    const headers = __spreadValues(__spreadValues({}, this.generateAccessTokenHeaders()), config == null ? void 0 : config.headers);
    let res;
    try {
      res = await this.instance.post(url, data, __spreadProps(__spreadValues({}, config), { headers }));
    } catch (error) {
      if (error instanceof Error) {
        return { res: null, error };
      }
    }
    if (!res) {
      return {
        res: null,
        error: new Error("Unable to make post request to funtion")
      };
    }
    return { res, error: null };
  }
  setAccessToken(accessToken) {
    if (!accessToken) {
      this.accessToken = null;
      return;
    }
    this.accessToken = accessToken;
  }
  generateAccessTokenHeaders() {
    if (this.adminSecret) {
      return {
        "x-hasura-admin-secret": this.adminSecret
      };
    }
    if (this.accessToken) {
      return {
        Authorization: `Bearer ${this.accessToken}`
      };
    }
    return {};
  }
}
class NhostGraphqlClient {
  constructor(params) {
    const { url, adminSecret } = params;
    this.url = url;
    this.accessToken = null;
    this.adminSecret = adminSecret;
    this.instance = axios.create({
      baseURL: url
    });
  }
  async request(document, variables, config) {
    const headers = __spreadValues(__spreadValues({}, this.generateAccessTokenHeaders()), config == null ? void 0 : config.headers);
    try {
      const operationName = "";
      const res = await this.instance.post("", {
        operationName: operationName || void 0,
        query: typeof document === "string" ? document : print(document),
        variables
      }, __spreadProps(__spreadValues({}, config), { headers }));
      const responseData = res.data;
      const { data } = responseData;
      if (responseData.errors) {
        return {
          data: null,
          error: responseData.errors
        };
      }
      if (typeof data !== "object" || Array.isArray(data) || data === null) {
        return {
          data: null,
          error: new Error("incorrect response data from GraphQL server")
        };
      }
      return { data, error: null };
    } catch (error) {
      if (error instanceof Error) {
        return { data: null, error };
      }
      console.error(error);
      return {
        data: null,
        error: new Error("Unable to get do GraphQL request")
      };
    }
  }
  getUrl() {
    return this.url;
  }
  setAccessToken(accessToken) {
    if (!accessToken) {
      this.accessToken = null;
      return;
    }
    this.accessToken = accessToken;
  }
  generateAccessTokenHeaders() {
    if (this.adminSecret) {
      return {
        "x-hasura-admin-secret": this.adminSecret
      };
    }
    if (this.accessToken) {
      return {
        Authorization: `Bearer ${this.accessToken}`
      };
    }
    return {};
  }
}
const LOCALHOST_REGEX = /^localhost(:\d+)*$/g;
function urlFromParams(backendOrSubdomain, service) {
  const { backendUrl, subdomain, region } = backendOrSubdomain;
  if (!backendUrl && !subdomain) {
    throw new Error("Either `backendUrl` or `subdomain` must be set.");
  }
  if (backendUrl) {
    return `${backendUrl}/v1/${service}`;
  }
  if (!subdomain) {
    throw new Error("`subdomain` must be set if `backendUrl` is not set.");
  }
  const subdomainLocalhostFound = subdomain.match(LOCALHOST_REGEX);
  if (subdomainLocalhostFound && subdomainLocalhostFound.length > 0) {
    const localhostFound = subdomainLocalhostFound[0];
    if (localhostFound === "localhost") {
      return `http://localhost:1337/v1/${service}`;
    }
    return `http://${localhostFound}/v1/${service}`;
  }
  if (!region) {
    throw new Error('`region` must be set when using a `subdomain` other than "localhost".');
  }
  return `https://${subdomain}.${service}.${region}.nhost.run/v1`;
}
class NhostClient {
  constructor(_a) {
    var _b = _a, {
      refreshIntervalTime,
      clientStorageGetter,
      clientStorageSetter,
      clientStorage,
      clientStorageType,
      autoRefreshToken,
      autoSignIn,
      adminSecret,
      devTools,
      start = true
    } = _b, urlParams = __objRest(_b, [
      "refreshIntervalTime",
      "clientStorageGetter",
      "clientStorageSetter",
      "clientStorage",
      "clientStorageType",
      "autoRefreshToken",
      "autoSignIn",
      "adminSecret",
      "devTools",
      "start"
    ]);
    var _a2;
    this.auth = new HasuraAuthClient({
      url: urlFromParams(urlParams, "auth"),
      refreshIntervalTime,
      clientStorageGetter,
      clientStorageSetter,
      clientStorage,
      clientStorageType,
      autoRefreshToken,
      autoSignIn,
      start
    });
    this.storage = new HasuraStorageClient({
      url: urlFromParams(urlParams, "storage"),
      adminSecret
    });
    this.functions = new NhostFunctionsClient({
      url: urlFromParams(urlParams, "functions"),
      adminSecret
    });
    this.graphql = new NhostGraphqlClient({
      url: urlFromParams(urlParams, "graphql"),
      adminSecret
    });
    this.storage.setAccessToken(this.auth.getAccessToken());
    this.functions.setAccessToken(this.auth.getAccessToken());
    this.graphql.setAccessToken(this.auth.getAccessToken());
    (_a2 = this.auth.client) == null ? void 0 : _a2.onStart(() => {
      this.auth.onAuthStateChanged((_event, session) => {
        if (_event === "SIGNED_OUT") {
          this.storage.setAccessToken(void 0);
          this.functions.setAccessToken(void 0);
          this.graphql.setAccessToken(void 0);
        }
      });
      this.auth.onTokenChanged((session) => {
        this.storage.setAccessToken(session == null ? void 0 : session.accessToken);
        this.functions.setAccessToken(session == null ? void 0 : session.accessToken);
        this.graphql.setAccessToken(session == null ? void 0 : session.accessToken);
      });
    });
    this._adminSecret = adminSecret;
    this.devTools = devTools;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(newValue) {
    this._adminSecret = newValue;
    this.storage.setAdminSecret(newValue);
  }
}
const createClient = (config) => new NhostClient(config);
export { NhostClient, NhostFunctionsClient, NhostGraphqlClient, createClient };
//# sourceMappingURL=index.esm.js.map
