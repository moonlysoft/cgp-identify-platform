var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { createMachine, assign, send, interpret } from "xstate";
import axios from "axios";
import Cookies from "js-cookie";
function utf8StringToBuffer(value) {
  return new TextEncoder().encode(value);
}
function bufferToBase64URLString(buffer) {
  const bytes = new Uint8Array(buffer);
  let str = "";
  for (const charCode of bytes) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function base64URLStringToBuffer(base64URLString) {
  const base64 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
  const padLength = (4 - base64.length % 4) % 4;
  const padded = base64.padEnd(base64.length + padLength, "=");
  const binary = atob(padded);
  const buffer = new ArrayBuffer(binary.length);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}
function browserSupportsWebAuthn() {
  return (window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential === "function";
}
function toPublicKeyCredentialDescriptor(descriptor) {
  const { id } = descriptor;
  return __spreadProps(__spreadValues({}, descriptor), {
    id: base64URLStringToBuffer(id),
    transports: descriptor.transports
  });
}
function isValidDomain(hostname) {
  return hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname);
}
class WebAuthnError extends Error {
  constructor(message, name = "WebAuthnError") {
    super(message);
    this.name = name;
  }
}
function identifyRegistrationError({ error, options }) {
  var _a, _b;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal === new AbortController().signal) {
      return new WebAuthnError("Registration ceremony was sent an abort signal", "AbortError");
    }
  } else if (error.name === "ConstraintError") {
    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {
      return new WebAuthnError("Discoverable credentials were required but no available authenticator supported it", "ConstraintError");
    } else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required") {
      return new WebAuthnError("User verification was required but no available authenticator supported it", "ConstraintError");
    }
  } else if (error.name === "InvalidStateError") {
    return new WebAuthnError("The authenticator was previously registered", "InvalidStateError");
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError("User clicked cancel, or the registration ceremony timed out", "NotAllowedError");
  } else if (error.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError('No entry in pubKeyCredParams was of type "public-key"', "NotSupportedError");
    }
    return new WebAuthnError("No available authenticator supported any of the specified pubKeyCredParams algorithms", "NotSupportedError");
  } else if (error.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError(`The RP ID "${publicKey.rp.id}" is invalid for this domain`, "SecurityError");
    }
  } else if (error.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError("User ID was not between 1 and 64 characters", "TypeError");
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError("The authenticator was unable to process the specified options, or could not create a new credential", "UnknownError");
  }
  return error;
}
class WebAuthnAbortService {
  createNewAbortSignal() {
    if (this.controller) {
      this.controller.abort();
    }
    this.controller = new AbortController();
    return this.controller.signal;
  }
  reset() {
    this.controller = void 0;
  }
}
const webauthnAbortService = new WebAuthnAbortService();
async function startRegistration(creationOptionsJSON) {
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  const publicKey = __spreadProps(__spreadValues({}, creationOptionsJSON), {
    challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),
    user: __spreadProps(__spreadValues({}, creationOptionsJSON.user), {
      id: utf8StringToBuffer(creationOptionsJSON.user.id)
    }),
    excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor)
  });
  const options = { publicKey };
  options.signal = webauthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.create(options);
  } catch (err) {
    throw identifyRegistrationError({ error: err, options });
  } finally {
    webauthnAbortService.reset();
  }
  if (!credential) {
    throw new Error("Registration was not completed");
  }
  const { id, rawId, response, type } = credential;
  const credentialJSON = {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      attestationObject: bufferToBase64URLString(response.attestationObject),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON)
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: credential.authenticatorAttachment
  };
  if (typeof response.getTransports === "function") {
    credentialJSON.transports = response.getTransports();
  }
  return credentialJSON;
}
function bufferToUTF8String(value) {
  return new TextDecoder("utf-8").decode(value);
}
async function browserSupportsWebAuthnAutofill() {
  if (navigator.credentials.conditionalMediationSupported) {
    return true;
  }
  const globalPublicKeyCredential = window.PublicKeyCredential;
  return globalPublicKeyCredential.isConditionalMediationAvailable !== void 0 && globalPublicKeyCredential.isConditionalMediationAvailable();
}
function identifyAuthenticationError({ error, options }) {
  var _a;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal === new AbortController().signal) {
      return new WebAuthnError("Authentication ceremony was sent an abort signal", "AbortError");
    }
  } else if (error.name === "NotAllowedError") {
    if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {
      return new WebAuthnError("No available authenticator recognized any of the allowed credentials", "NotAllowedError");
    }
    return new WebAuthnError("User clicked cancel, or the authentication ceremony timed out", "NotAllowedError");
  } else if (error.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError(`The RP ID "${publicKey.rpId}" is invalid for this domain`, "SecurityError");
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError("The authenticator was unable to process the specified options, or could not create a new assertion signature", "UnknownError");
  }
  return error;
}
async function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {
  var _a, _b;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  let allowCredentials;
  if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
    allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);
  }
  const publicKey = __spreadProps(__spreadValues({}, requestOptionsJSON), {
    challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),
    allowCredentials
  });
  const options = {};
  if (useBrowserAutofill) {
    if (!await browserSupportsWebAuthnAutofill()) {
      throw Error("Browser does not support WebAuthn autofill");
    }
    const eligibleInputs = document.querySelectorAll("input[autocomplete*='webauthn']");
    if (eligibleInputs.length < 1) {
      throw Error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');
    }
    options.mediation = "conditional";
    publicKey.allowCredentials = [];
  }
  options.publicKey = publicKey;
  options.signal = webauthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.get(options);
  } catch (err) {
    throw identifyAuthenticationError({ error: err, options });
  } finally {
    webauthnAbortService.reset();
  }
  if (!credential) {
    throw new Error("Authentication was not completed");
  }
  const { id, rawId, response, type } = credential;
  let userHandle = void 0;
  if (response.userHandle) {
    userHandle = bufferToUTF8String(response.userHandle);
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      authenticatorData: bufferToBase64URLString(response.authenticatorData),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      signature: bufferToBase64URLString(response.signature),
      userHandle
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: credential.authenticatorAttachment
  };
}
const NHOST_REFRESH_TOKEN_KEY = "nhostRefreshToken";
const NHOST_JWT_EXPIRES_AT_KEY = "nhostRefreshTokenExpiresAt";
const MIN_PASSWORD_LENGTH = 3;
const TOKEN_REFRESH_MARGIN = 300;
const REFRESH_TOKEN_RETRY_INTERVAL = 5;
const REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30;
const NETWORK_ERROR_CODE = 0;
const OTHER_ERROR_CODE = 1;
const VALIDATION_ERROR_CODE = 10;
const STATE_ERROR_CODE = 20;
class CodifiedError extends Error {
  constructor(original) {
    super(original.message);
    Error.captureStackTrace(this, this.constructor);
    if (original instanceof Error) {
      this.name = original.name;
      this.error = {
        error: original.name,
        status: OTHER_ERROR_CODE,
        message: original.message
      };
    } else {
      this.name = original.error;
      this.error = original;
    }
  }
}
const INVALID_EMAIL_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-email",
  message: "Email is incorrectly formatted"
};
const INVALID_MFA_TYPE_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-mfa-type",
  message: "MFA type is invalid"
};
const INVALID_MFA_CODE_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-mfa-code",
  message: "MFA code is invalid"
};
const INVALID_PASSWORD_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-password",
  message: "Password is incorrectly formatted"
};
const INVALID_PHONE_NUMBER_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-phone-number",
  message: "Phone number is incorrectly formatted"
};
const INVALID_MFA_TICKET_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-mfa-ticket",
  message: "MFA ticket is invalid"
};
const NO_MFA_TICKET_ERROR = {
  status: VALIDATION_ERROR_CODE,
  error: "no-mfa-ticket",
  message: "No MFA ticket has been provided"
};
const NO_REFRESH_TOKEN = {
  status: VALIDATION_ERROR_CODE,
  error: "no-refresh-token",
  message: "No refresh token has been provided"
};
const TOKEN_REFRESHER_RUNNING_ERROR = {
  status: STATE_ERROR_CODE,
  error: "refresher-already-running",
  message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
};
const USER_ALREADY_SIGNED_IN = {
  status: STATE_ERROR_CODE,
  error: "already-signed-in",
  message: "User is already signed in"
};
const USER_UNAUTHENTICATED = {
  status: STATE_ERROR_CODE,
  error: "unauthenticated-user",
  message: "User is not authenticated"
};
const USER_NOT_ANONYMOUS = {
  status: STATE_ERROR_CODE,
  error: "user-not-anonymous",
  message: "User is not anonymous"
};
const EMAIL_NEEDS_VERIFICATION = {
  status: STATE_ERROR_CODE,
  error: "unverified-user",
  message: "Email needs verification"
};
const INVALID_REFRESH_TOKEN = {
  status: VALIDATION_ERROR_CODE,
  error: "invalid-refresh-token",
  message: "Invalid or expired refresh token"
};
const nhostApiClient = (backendUrl) => {
  const client = axios.create({ baseURL: backendUrl });
  client.interceptors.response.use((response) => response, (error) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    return Promise.reject({
      error: {
        message: (_e = (_d = (_c = (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) != null ? _c : error.message) != null ? _d : error.request.responseText) != null ? _e : JSON.stringify(error),
        status: (_i = (_h = (_f = error.response) == null ? void 0 : _f.status) != null ? _h : (_g = error.response) == null ? void 0 : _g.data.statusCode) != null ? _i : NETWORK_ERROR_CODE,
        error: ((_j = error.response) == null ? void 0 : _j.data.error) || error.request.statusText || "network"
      }
    });
  });
  return client;
};
const isBrowser$1 = typeof window !== "undefined";
const inMemoryLocalStorage = /* @__PURE__ */ new Map();
const defaultClientStorageGetter = (key) => {
  var _a;
  if (isBrowser$1 && typeof localStorage !== "undefined")
    return localStorage.getItem(key);
  else
    return (_a = inMemoryLocalStorage.get(key)) != null ? _a : null;
};
const defaultClientStorageSetter = (key, value) => {
  if (isBrowser$1 && typeof localStorage !== "undefined") {
    if (value) {
      localStorage.setItem(key, value);
    } else {
      localStorage.removeItem(key);
    }
  } else {
    if (value) {
      inMemoryLocalStorage.set(key, value);
    } else if (inMemoryLocalStorage.has(key)) {
      inMemoryLocalStorage.delete(key);
    }
  }
};
const localStorageGetter = (clientStorageType, clientStorage) => {
  if (clientStorageType === "localStorage" || clientStorageType === "web") {
    return defaultClientStorageGetter;
  }
  if (clientStorageType === "cookie") {
    return (key) => {
      var _a;
      if (isBrowser$1) {
        return (_a = Cookies.get(key)) != null ? _a : null;
      } else {
        return null;
      }
    };
  }
  if (!clientStorage) {
    throw Error(`clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`);
  }
  if (clientStorageType === "react-native") {
    return (key) => {
      var _a;
      return (_a = clientStorage.getItem) == null ? void 0 : _a.call(clientStorage, key);
    };
  }
  if (clientStorageType === "capacitor") {
    return (key) => {
      var _a;
      return (_a = clientStorage.get) == null ? void 0 : _a.call(clientStorage, { key });
    };
  }
  if (clientStorageType === "expo-secure-storage") {
    return (key) => {
      var _a;
      return (_a = clientStorage.getItemAsync) == null ? void 0 : _a.call(clientStorage, key);
    };
  }
  if (clientStorageType === "custom") {
    if (clientStorage.getItem && clientStorage.removeItem) {
      return clientStorage.getItem;
    }
    if (clientStorage.getItemAsync) {
      return clientStorage.getItemAsync;
    }
    throw Error(`clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`);
  }
  throw Error(`Unknown storage type: ${clientStorageType}`);
};
const localStorageSetter = (clientStorageType, clientStorage) => {
  if (clientStorageType === "localStorage" || clientStorageType === "web") {
    return defaultClientStorageSetter;
  }
  if (clientStorageType === "cookie") {
    return (key, value) => {
      if (isBrowser$1) {
        if (value) {
          Cookies.set(key, value, { expires: 30 });
        } else {
          Cookies.remove(key);
        }
      }
    };
  }
  if (!clientStorage) {
    throw Error(`clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`);
  }
  if (clientStorageType === "react-native") {
    return (key, value) => {
      var _a, _b;
      return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);
    };
  }
  if (clientStorageType === "capacitor") {
    return (key, value) => {
      var _a, _b;
      return value ? (_a = clientStorage.set) == null ? void 0 : _a.call(clientStorage, { key, value }) : (_b = clientStorage.remove) == null ? void 0 : _b.call(clientStorage, { key });
    };
  }
  if (clientStorageType === "expo-secure-storage") {
    return async (key, value) => {
      var _a, _b;
      return value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.deleteItemAsync) == null ? void 0 : _b.call(clientStorage, key);
    };
  }
  if (clientStorageType === "custom") {
    if (!clientStorage.removeItem) {
      throw Error(`clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`);
    }
    if (clientStorage.setItem) {
      return (key, value) => {
        var _a, _b;
        return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);
      };
    }
    if (clientStorage.setItemAsync) {
      return async (key, value) => {
        var _a, _b;
        return value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);
      };
    }
    throw Error(`clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`);
  }
  throw Error(`Unknown storage type: ${clientStorageType}`);
};
const encodeQueryParameters = (baseUrl, parameters) => {
  const encodedParameters = parameters && Object.entries(parameters).map(([key, value]) => {
    const stringValue = Array.isArray(value) ? value.join(",") : typeof value === "object" ? JSON.stringify(value) : value;
    return `${key}=${encodeURIComponent(stringValue)}`;
  }).join("&");
  if (encodedParameters)
    return `${baseUrl}?${encodedParameters}`;
  else
    return baseUrl;
};
const rewriteRedirectTo = (clientUrl, options) => {
  if (!(options == null ? void 0 : options.redirectTo)) {
    return options;
  }
  const _a = options, { redirectTo } = _a, otherOptions = __objRest(_a, ["redirectTo"]);
  if (!clientUrl) {
    if (redirectTo.startsWith("/")) {
      return otherOptions;
    } else {
      return options;
    }
  }
  const baseClientUrl = new URL(clientUrl);
  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search));
  const url = new URL(redirectTo.startsWith("/") ? baseClientUrl.origin + redirectTo : redirectTo);
  const additionalParams = new URLSearchParams(url.search);
  let combinedParams = Object.fromEntries(additionalParams);
  if (redirectTo.startsWith("/")) {
    combinedParams = __spreadValues(__spreadValues({}, clientParams), combinedParams);
  }
  let pathName = baseClientUrl.pathname;
  if (url.pathname.length > 1) {
    pathName += url.pathname.slice(1);
  }
  return __spreadProps(__spreadValues({}, otherOptions), {
    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)
  });
};
function getParameterByName(name, url) {
  var _a;
  if (!url) {
    if (typeof window === "undefined") {
      return;
    }
    url = ((_a = window.location) == null ? void 0 : _a.href) || "";
  }
  name = name.replace(/[\[\]]/g, "\\$&");
  const regex = new RegExp("[?&#]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
  if (!results)
    return null;
  if (!results[2])
    return "";
  return decodeURIComponent(results[2].replace(/\+/g, " "));
}
function removeParameterFromWindow(name) {
  var _a;
  if (typeof window === "undefined") {
    return;
  }
  const location = window == null ? void 0 : window.location;
  if (!location) {
    return;
  }
  if (location) {
    const search = new URLSearchParams(location.search);
    const hash = new URLSearchParams((_a = location.hash) == null ? void 0 : _a.slice(1));
    search.delete(name);
    hash.delete(name);
    let url = window.location.pathname;
    if (Array.from(search).length)
      url += `?${search.toString()}`;
    if (Array.from(hash).length)
      url += `#${hash.toString()}`;
    window.history.pushState({}, "", url);
  }
}
const isValidEmail = (email) => !!email && typeof email === "string" && !!String(email).toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
const isValidPassword = (password) => !!password && typeof password === "string" && password.length >= MIN_PASSWORD_LENGTH;
const isValidPhoneNumber = (phoneNumber) => !!phoneNumber && typeof phoneNumber === "string";
const isValidTicket = (ticket) => ticket && typeof ticket === "string" && ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);
const INITIAL_MACHINE_CONTEXT = {
  user: null,
  mfa: null,
  accessToken: {
    value: null,
    expiresAt: null
  },
  refreshTimer: {
    startedAt: null,
    attempts: 0,
    lastAttempt: null
  },
  refreshToken: {
    value: null
  },
  errors: {}
};
const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }) => {
  const api = nhostApiClient(backendUrl);
  return createMachine({
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    preserveActionOrder: true,
    id: "changeEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  }, {
    actions: {
      saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),
      saveRequestError: assign({
        error: (_, { data: { error } }) => error
      }),
      reportError: send((ctx) => ({ type: "ERROR", error: ctx.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (_, { email }) => !isValidEmail(email)
    },
    services: {
      requestChange: async (_, { email, options }) => {
        const res = await api.post("/user/email/change", {
          newEmail: email,
          options: rewriteRedirectTo(clientUrl, options)
        }, {
          headers: {
            authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`
          }
        });
        return res.data;
      }
    }
  });
};
const createChangePasswordMachine = ({ backendUrl, interpreter }) => {
  const api = nhostApiClient(backendUrl);
  return createMachine({
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    preserveActionOrder: true,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidPassword",
              actions: "saveInvalidPasswordError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  }, {
    actions: {
      saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),
      saveRequestError: assign({
        error: (_, { data: { error } }) => error
      }),
      reportError: send((ctx) => ({ type: "ERROR", error: ctx.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidPassword: (_, { password }) => !isValidPassword(password)
    },
    services: {
      requestChange: (_, { password, ticket }) => api.post("/user/password", { newPassword: password, ticket }, {
        headers: {
          authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`
        }
      })
    }
  });
};
const createEnableMfaMachine = ({ backendUrl, interpreter }) => {
  const api = nhostApiClient(backendUrl);
  return createMachine({
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    preserveActionOrder: true,
    id: "enableMfa",
    initial: "idle",
    context: { error: null, imageUrl: null, secret: null },
    states: {
      idle: {
        initial: "initial",
        on: {
          GENERATE: "generating"
        },
        states: {
          initial: {},
          error: {}
        }
      },
      generating: {
        invoke: {
          src: "generate",
          id: "generate",
          onDone: { target: "generated", actions: ["reportGeneratedSuccess", "saveGeneration"] },
          onError: { actions: ["saveError", "reportGeneratedError"], target: "idle.error" }
        }
      },
      generated: {
        initial: "idle",
        states: {
          idle: {
            initial: "idle",
            on: {
              ACTIVATE: [
                {
                  cond: "invalidMfaType",
                  actions: "saveInvalidMfaTypeError",
                  target: ".error"
                },
                {
                  cond: "invalidMfaCode",
                  actions: "saveInvalidMfaCodeError",
                  target: ".error"
                },
                {
                  target: "activating"
                }
              ]
            },
            states: { idle: {}, error: {} }
          },
          activating: {
            invoke: {
              src: "activate",
              id: "activate",
              onDone: { target: "activated", actions: "reportSuccess" },
              onError: { actions: ["saveError", "reportError"], target: "idle.error" }
            }
          },
          activated: { type: "final" }
        }
      }
    }
  }, {
    actions: {
      saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),
      saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),
      saveError: assign({
        error: (_, { data: { error } }) => error
      }),
      saveGeneration: assign({
        imageUrl: (_, { data: { imageUrl } }) => imageUrl,
        secret: (_, { data: { totpSecret } }) => totpSecret
      }),
      reportError: send((ctx) => ({ type: "ERROR", error: ctx.error })),
      reportSuccess: send("SUCCESS"),
      reportGeneratedSuccess: send("GENERATED"),
      reportGeneratedError: send((ctx) => ({ type: "GENERATED_ERROR", error: ctx.error }))
    },
    guards: {
      invalidMfaCode: (_, { code }) => !code,
      invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== "totp"
    },
    services: {
      generate: async (_) => {
        const { data } = await api.get("/mfa/totp/generate", {
          headers: {
            authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`
          }
        });
        return data;
      },
      activate: (_, { code, activeMfaType }) => api.post("/user/mfa", {
        code,
        activeMfaType
      }, {
        headers: {
          authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`
        }
      })
    }
  });
};
const createResetPasswordMachine = ({ backendUrl, clientUrl }) => {
  const api = nhostApiClient(backendUrl);
  return createMachine({
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    preserveActionOrder: true,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  }, {
    actions: {
      saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),
      saveRequestError: assign({
        error: (_, { data: { error } }) => error
      }),
      reportError: send((ctx) => ({ type: "ERROR", error: ctx.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (_, { email }) => !isValidEmail(email)
    },
    services: {
      requestChange: (_, { email, options }) => api.post("/user/password/reset", {
        email,
        options: rewriteRedirectTo(clientUrl, options)
      })
    }
  });
};
const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }) => {
  const api = nhostApiClient(backendUrl);
  return createMachine({
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    preserveActionOrder: true,
    id: "sendVerificationEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "request",
          id: "request",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  }, {
    actions: {
      saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),
      saveRequestError: assign({
        error: (_, { data: { error } }) => error
      }),
      reportError: send((ctx) => ({ type: "ERROR", error: ctx.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (_, { email }) => !isValidEmail(email)
    },
    services: {
      request: async (_, { email, options }) => {
        const res = await api.post("/user/email/send-verification-email", {
          email,
          options: rewriteRedirectTo(clientUrl, options)
        });
        return res.data;
      }
    }
  });
};
const createAuthMachine = ({
  backendUrl,
  clientUrl,
  clientStorageGetter,
  clientStorageSetter,
  clientStorageType = "web",
  clientStorage,
  refreshIntervalTime,
  autoRefreshToken = true,
  autoSignIn = true
}) => {
  const storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage);
  const storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage);
  const api = nhostApiClient(backendUrl);
  const postRequest = async (url, data, config) => {
    const result = await api.post(url, data, config);
    return result.data;
  };
  return createMachine({
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    context: INITIAL_MACHINE_CONTEXT,
    preserveActionOrder: true,
    id: "nhost",
    type: "parallel",
    states: {
      authentication: {
        initial: "starting",
        on: {
          SESSION_UPDATE: [
            {
              cond: "hasSession",
              actions: ["saveSession", "resetTimer", "reportTokenChanged"],
              target: ".signedIn"
            }
          ]
        },
        states: {
          starting: {
            entry: "resetErrors",
            tags: ["loading"],
            always: { cond: "isSignedIn", target: "signedIn" },
            invoke: {
              id: "importRefreshToken",
              src: "importRefreshToken",
              onDone: {
                actions: ["saveSession", "reportTokenChanged"],
                target: "signedIn"
              },
              onError: { actions: ["saveAuthenticationError"], target: "signedOut" }
            }
          },
          signedOut: {
            initial: "noErrors",
            entry: "reportSignedOut",
            states: {
              noErrors: {},
              success: {},
              needsSmsOtp: {},
              needsMfa: {},
              failed: {},
              signingOut: {
                entry: ["clearContextExceptRefreshToken"],
                exit: ["destroyRefreshToken", "reportTokenChanged"],
                invoke: {
                  src: "signout",
                  id: "signingOut",
                  onDone: {
                    target: "success"
                  },
                  onError: {
                    target: "failed",
                    actions: ["saveAuthenticationError"]
                  }
                }
              }
            },
            on: {
              SIGNIN_PASSWORD: "authenticating.password",
              SIGNIN_ANONYMOUS: "authenticating.anonymous",
              SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
              SIGNIN_MFA_TOTP: "authenticating.mfa.totp"
            }
          },
          authenticating: {
            entry: "resetErrors",
            states: {
              password: {
                invoke: {
                  src: "signInPassword",
                  id: "authenticateUserWithPassword",
                  onDone: [
                    {
                      cond: "hasMfaTicket",
                      actions: ["saveMfaTicket"],
                      target: "#nhost.authentication.signedOut.needsMfa"
                    },
                    {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    }
                  ],
                  onError: [
                    {
                      cond: "unverified",
                      target: [
                        "#nhost.authentication.signedOut",
                        "#nhost.registration.incomplete.needsEmailVerification"
                      ]
                    },
                    {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  ]
                }
              },
              anonymous: {
                invoke: {
                  src: "signInAnonymous",
                  id: "authenticateAnonymously",
                  onDone: {
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  onError: {
                    actions: "saveAuthenticationError",
                    target: "#nhost.authentication.signedOut.failed"
                  }
                }
              },
              mfa: {
                states: {
                  totp: {
                    invoke: {
                      src: "signInMfaTotp",
                      id: "signInMfaTotp",
                      onDone: {
                        actions: ["saveSession", "reportTokenChanged"],
                        target: "#nhost.authentication.signedIn"
                      },
                      onError: {
                        actions: ["saveAuthenticationError"],
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    }
                  }
                }
              },
              securityKeyEmail: {
                invoke: {
                  src: "signInSecurityKeyEmail",
                  id: "authenticateUserWithSecurityKey",
                  onDone: {
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  onError: [
                    {
                      cond: "unverified",
                      target: [
                        "#nhost.authentication.signedOut",
                        "#nhost.registration.incomplete.needsEmailVerification"
                      ]
                    },
                    {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  ]
                }
              }
            }
          },
          signedIn: {
            type: "parallel",
            entry: ["reportSignedIn", "cleanUrl", "broadcastToken", "resetErrors"],
            on: {
              SIGNOUT: "signedOut.signingOut"
            },
            states: {
              refreshTimer: {
                id: "timer",
                initial: "idle",
                states: {
                  disabled: { type: "final" },
                  stopped: {
                    always: {
                      cond: "noToken",
                      target: "idle"
                    }
                  },
                  idle: {
                    always: [
                      { cond: "isAutoRefreshDisabled", target: "disabled" },
                      {
                        cond: "hasRefreshToken",
                        target: "running"
                      }
                    ]
                  },
                  running: {
                    initial: "pending",
                    entry: "resetTimer",
                    states: {
                      pending: {
                        after: {
                          "1000": {
                            internal: false,
                            target: "pending"
                          }
                        },
                        always: {
                          cond: "refreshTimerShouldRefresh",
                          target: "refreshing"
                        }
                      },
                      refreshing: {
                        invoke: {
                          src: "refreshToken",
                          id: "refreshToken",
                          onDone: {
                            actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                            target: "pending"
                          },
                          onError: [
                            { actions: "saveRefreshAttempt", target: "pending" }
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      token: {
        initial: "idle",
        states: {
          idle: {
            on: {
              TRY_TOKEN: "running"
            },
            initial: "noErrors",
            states: { noErrors: {}, error: {} }
          },
          running: {
            invoke: {
              src: "refreshToken",
              id: "authenticateWithToken",
              onDone: {
                actions: ["saveSession", "reportTokenChanged"],
                target: ["#nhost.authentication.signedIn", "idle.noErrors"]
              },
              onError: [
                { cond: "isSignedIn", target: "idle.error" },
                {
                  actions: "saveAuthenticationError",
                  target: ["#nhost.authentication.signedOut.failed", "idle.error"]
                }
              ]
            }
          }
        }
      },
      registration: {
        initial: "incomplete",
        on: {
          SIGNED_IN: [{ cond: "isAnonymous", target: ".incomplete" }, ".complete"]
        },
        states: {
          incomplete: {
            on: {
              SIGNUP_EMAIL_PASSWORD: "emailPassword",
              SIGNUP_SECURITY_KEY: "securityKey",
              PASSWORDLESS_EMAIL: "passwordlessEmail",
              PASSWORDLESS_SMS: "passwordlessSms",
              PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp"
            },
            initial: "noErrors",
            states: {
              noErrors: {},
              needsEmailVerification: {},
              needsOtp: {},
              failed: {}
            }
          },
          emailPassword: {
            entry: ["resetErrors"],
            invoke: {
              src: "signUpEmailPassword",
              id: "signUpEmailPassword",
              onDone: [
                {
                  cond: "hasSession",
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                }
              ],
              onError: [
                {
                  cond: "unverified",
                  target: "incomplete.needsEmailVerification"
                },
                {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              ]
            }
          },
          securityKey: {
            entry: ["resetErrors"],
            invoke: {
              src: "signUpSecurityKey",
              id: "signUpSecurityKey",
              onDone: [
                {
                  cond: "hasSession",
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                }
              ],
              onError: [
                {
                  cond: "unverified",
                  target: "incomplete.needsEmailVerification"
                },
                {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              ]
            }
          },
          passwordlessEmail: {
            entry: ["resetErrors"],
            invoke: {
              src: "passwordlessEmail",
              id: "passwordlessEmail",
              onDone: {
                actions: "clearContext",
                target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
              },
              onError: {
                actions: "saveRegistrationError",
                target: "incomplete.failed"
              }
            }
          },
          passwordlessSms: {
            entry: ["resetErrors"],
            invoke: {
              src: "passwordlessSms",
              id: "passwordlessSms",
              onDone: {
                actions: "clearContext",
                target: ["#nhost.authentication.signedOut", "incomplete.needsOtp"]
              },
              onError: {
                actions: "saveRegistrationError",
                target: "incomplete.failed"
              }
            }
          },
          passwordlessSmsOtp: {
            entry: ["resetErrors"],
            invoke: {
              src: "passwordlessSmsOtp",
              id: "passwordlessSmsOtp",
              onDone: {
                actions: ["saveSession", "reportTokenChanged"],
                target: "#nhost.authentication.signedIn"
              },
              onError: {
                actions: "saveRegistrationError",
                target: "incomplete.failed"
              }
            }
          },
          complete: {
            on: {
              SIGNED_OUT: "incomplete"
            }
          }
        }
      }
    }
  }, {
    actions: {
      reportSignedIn: send("SIGNED_IN"),
      reportSignedOut: send("SIGNED_OUT"),
      reportTokenChanged: send("TOKEN_CHANGED"),
      clearContext: assign(() => {
        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);
        storageSetter(NHOST_REFRESH_TOKEN_KEY, null);
        return __spreadValues({}, INITIAL_MACHINE_CONTEXT);
      }),
      clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {
        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);
        return __spreadProps(__spreadValues({}, INITIAL_MACHINE_CONTEXT), {
          refreshToken: { value }
        });
      }),
      saveSession: assign({
        user: (_, { data }) => {
          var _a;
          return ((_a = data == null ? void 0 : data.session) == null ? void 0 : _a.user) || null;
        },
        accessToken: (_, { data }) => {
          if (data.session) {
            const { accessTokenExpiresIn, accessToken } = data.session;
            const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1e3);
            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString());
            return {
              value: accessToken,
              expiresAt: nextRefresh
            };
          }
          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);
          return {
            value: null,
            expiresAt: null
          };
        },
        refreshToken: (_, { data }) => {
          var _a;
          const refreshToken = ((_a = data.session) == null ? void 0 : _a.refreshToken) || null;
          if (refreshToken) {
            storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken);
          }
          return { value: refreshToken };
        }
      }),
      saveMfaTicket: assign({
        mfa: (_, e) => {
          var _a;
          return (_a = e.data) == null ? void 0 : _a.mfa;
        }
      }),
      resetTimer: assign({
        refreshTimer: (_) => ({
          startedAt: new Date(),
          attempts: 0,
          lastAttempt: null
        })
      }),
      saveRefreshAttempt: assign({
        refreshTimer: (ctx, e) => ({
          startedAt: ctx.refreshTimer.startedAt,
          attempts: ctx.refreshTimer.attempts + 1,
          lastAttempt: new Date()
        })
      }),
      saveAuthenticationError: assign({
        errors: ({ errors }, { data: { error } }) => __spreadProps(__spreadValues({}, errors), {
          authentication: error
        })
      }),
      resetErrors: assign({
        errors: (_) => ({})
      }),
      saveRegistrationError: assign({
        errors: ({ errors }, { data: { error } }) => __spreadProps(__spreadValues({}, errors), { registration: error })
      }),
      destroyRefreshToken: assign({
        refreshToken: (_) => {
          storageSetter(NHOST_REFRESH_TOKEN_KEY, null);
          return { value: null };
        }
      }),
      cleanUrl: () => {
        if (autoSignIn && getParameterByName("refreshToken")) {
          removeParameterFromWindow("refreshToken");
          removeParameterFromWindow("type");
        }
      },
      broadcastToken: (context) => {
        if (autoSignIn) {
          try {
            const channel = new BroadcastChannel("nhost");
            channel.postMessage(context.refreshToken.value);
          } catch (error) {
          }
        }
      }
    },
    guards: {
      isAnonymous: (ctx, e) => {
        var _a;
        return !!((_a = ctx.user) == null ? void 0 : _a.isAnonymous);
      },
      isSignedIn: (ctx) => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,
      noToken: (ctx) => !ctx.refreshToken.value,
      hasRefreshToken: (ctx) => !!ctx.refreshToken.value,
      isAutoRefreshDisabled: () => !autoRefreshToken,
      refreshTimerShouldRefresh: (ctx) => {
        const { expiresAt } = ctx.accessToken;
        if (!expiresAt) {
          return false;
        }
        if (ctx.refreshTimer.lastAttempt) {
          const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime();
          return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1e3;
        }
        if (refreshIntervalTime) {
          const elapsed = Date.now() - ctx.refreshTimer.startedAt.getTime();
          if (elapsed > refreshIntervalTime * 1e3) {
            return true;
          }
        }
        const expiresIn = expiresAt.getTime() - Date.now();
        const remaining = expiresIn - 1e3 * TOKEN_REFRESH_MARGIN;
        return remaining <= 0;
      },
      unverified: (_, { data: { error } }) => error.status === 401 && (error.message === "Email is not verified" || error.error === "unverified-user"),
      hasSession: (_, e) => {
        var _a;
        return !!((_a = e.data) == null ? void 0 : _a.session);
      },
      hasMfaTicket: (_, e) => {
        var _a;
        return !!((_a = e.data) == null ? void 0 : _a.mfa);
      }
    },
    services: {
      signInPassword: (_, { email, password }) => {
        if (!isValidEmail(email)) {
          return Promise.reject({ error: INVALID_EMAIL_ERROR });
        }
        if (!isValidPassword(password)) {
          return Promise.reject({ error: INVALID_PASSWORD_ERROR });
        }
        return postRequest("/signin/email-password", {
          email,
          password
        });
      },
      passwordlessSms: (context, { phoneNumber, options }) => {
        var _a;
        if (!isValidPhoneNumber(phoneNumber)) {
          return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR });
        }
        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {
          console.warn("Deanonymisation from a phone number is not yet implemented in hasura-auth");
          return postRequest("/user/deanonymize", {
            signInMethod: "passwordless",
            connection: "sms",
            phoneNumber,
            options: rewriteRedirectTo(clientUrl, options)
          }, {
            headers: {
              authorization: `Bearer ${context.accessToken.value}`
            }
          });
        } else {
          return postRequest("/signin/passwordless/sms", {
            phoneNumber,
            options: rewriteRedirectTo(clientUrl, options)
          });
        }
      },
      passwordlessSmsOtp: (_, { phoneNumber, otp }) => {
        if (!isValidPhoneNumber(phoneNumber)) {
          return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR });
        }
        return postRequest("/signin/passwordless/sms/otp", {
          phoneNumber,
          otp
        });
      },
      passwordlessEmail: (context, { email, options }) => {
        var _a;
        if (!isValidEmail(email)) {
          return Promise.reject({ error: INVALID_EMAIL_ERROR });
        }
        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {
          return postRequest("/user/deanonymize", {
            signInMethod: "passwordless",
            connection: "email",
            email,
            options: rewriteRedirectTo(clientUrl, options)
          }, {
            headers: {
              authorization: `Bearer ${context.accessToken.value}`
            }
          });
        } else {
          return postRequest("/signin/passwordless/email", {
            email,
            options: rewriteRedirectTo(clientUrl, options)
          });
        }
      },
      signInAnonymous: (_) => postRequest("/signin/anonymous"),
      signInMfaTotp: (context, data) => {
        var _a;
        const ticket = data.ticket || ((_a = context.mfa) == null ? void 0 : _a.ticket);
        if (!ticket) {
          return Promise.reject({ error: NO_MFA_TICKET_ERROR });
        }
        if (!isValidTicket(ticket)) {
          return Promise.reject({ error: INVALID_MFA_TICKET_ERROR });
        }
        return postRequest("/signin/mfa/totp", {
          ticket,
          otp: data.otp
        });
      },
      signInSecurityKeyEmail: async (_, { email }) => {
        if (!isValidEmail(email)) {
          throw new CodifiedError(INVALID_EMAIL_ERROR);
        }
        const options = await postRequest("/signin/webauthn", { email });
        let credential;
        try {
          credential = await startAuthentication(options);
        } catch (e) {
          throw new CodifiedError(e);
        }
        return postRequest("/signin/webauthn/verify", { email, credential });
      },
      refreshToken: async (ctx, event) => {
        const refreshToken = event.type === "TRY_TOKEN" ? event.token : ctx.refreshToken.value;
        const session = await postRequest("/token", {
          refreshToken
        });
        return { session, error: null };
      },
      signout: (ctx, e) => postRequest("/signout", {
        refreshToken: ctx.refreshToken.value,
        all: !!e.all
      }),
      signUpEmailPassword: async (context, { email, password, options }) => {
        var _a;
        if (!isValidEmail(email)) {
          return Promise.reject({ error: INVALID_EMAIL_ERROR });
        }
        if (!isValidPassword(password)) {
          return Promise.reject({ error: INVALID_PASSWORD_ERROR });
        }
        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {
          return postRequest("/user/deanonymize", {
            signInMethod: "email-password",
            email,
            password,
            options: rewriteRedirectTo(clientUrl, options)
          }, {
            headers: {
              authorization: `Bearer ${context.accessToken.value}`
            }
          });
        } else {
          return postRequest("/signup/email-password", {
            email,
            password,
            options: rewriteRedirectTo(clientUrl, options)
          });
        }
      },
      signUpSecurityKey: async (_, { email, options }) => {
        if (!isValidEmail(email)) {
          return Promise.reject({ error: INVALID_EMAIL_ERROR });
        }
        const nickname = options == null ? void 0 : options.nickname;
        if (nickname)
          delete options.nickname;
        const webAuthnOptions = await postRequest("/signup/webauthn", { email, options });
        let credential;
        try {
          credential = await startRegistration(webAuthnOptions);
        } catch (e) {
          throw new CodifiedError(e);
        }
        return postRequest("/signup/webauthn/verify", {
          credential,
          options: {
            redirectTo: options == null ? void 0 : options.redirectTo,
            nickname
          }
        });
      },
      importRefreshToken: async () => {
        let error = null;
        if (autoSignIn) {
          const urlToken = getParameterByName("refreshToken") || null;
          if (urlToken) {
            try {
              const session = await postRequest("/token", {
                refreshToken: urlToken
              });
              return { session, error: null };
            } catch (exception) {
              error = exception.error;
            }
          } else {
            const error2 = getParameterByName("error");
            if (error2) {
              return Promise.reject({
                session: null,
                error: {
                  status: VALIDATION_ERROR_CODE,
                  error: error2,
                  message: getParameterByName("errorDescription") || error2
                }
              });
            }
          }
        }
        const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY);
        if (storageToken) {
          try {
            const session = await postRequest("/token", {
              refreshToken: storageToken
            });
            return { session, error: null };
          } catch (exception) {
            error = exception.error;
          }
        }
        return Promise.reject({ error });
      }
    }
  });
};
class AuthClient {
  constructor(_a) {
    var _b = _a, {
      clientStorageType = "web",
      autoSignIn = true,
      autoRefreshToken = true,
      start = true,
      backendUrl,
      clientUrl,
      devTools
    } = _b, defaultOptions = __objRest(_b, [
      "clientStorageType",
      "autoSignIn",
      "autoRefreshToken",
      "start",
      "backendUrl",
      "clientUrl",
      "devTools"
    ]);
    this._subscriptions = /* @__PURE__ */ new Set();
    this.backendUrl = backendUrl;
    this.clientUrl = clientUrl;
    this.machine = createAuthMachine(__spreadProps(__spreadValues({}, defaultOptions), {
      backendUrl,
      clientUrl,
      clientStorageType,
      autoSignIn,
      autoRefreshToken
    }));
    if (start) {
      this.interpreter = interpret(this.machine, { devTools });
      this.interpreter.start();
    }
    if (typeof window !== "undefined" && autoSignIn) {
      try {
        this._channel = new BroadcastChannel("nhost");
        this._channel.addEventListener("message", (token) => {
          var _a2;
          const existingToken = (_a2 = this.interpreter) == null ? void 0 : _a2.state.context.refreshToken.value;
          if (this.interpreter && token.data !== existingToken) {
            this.interpreter.send("TRY_TOKEN", { token: token.data });
          }
        });
      } catch (error) {
      }
    }
  }
  get interpreter() {
    return this._interpreter;
  }
  set interpreter(interpreter) {
    this._interpreter = interpreter;
    if (interpreter) {
      this._subscriptions.forEach((fn) => fn(this));
    }
  }
  onStart(fn) {
    if (this.interpreter) {
      fn(this);
    } else {
      this._subscriptions.add(fn);
    }
  }
}
const isBrowser = typeof window !== "undefined";
class AuthCookieClient extends AuthClient {
  constructor(_c) {
    var options = __objRest(_c, []);
    super(__spreadProps(__spreadValues({}, options), {
      autoSignIn: isBrowser && options.autoSignIn,
      autoRefreshToken: isBrowser && options.autoRefreshToken,
      clientStorageType: "cookie"
    }));
  }
}
const AuthClientSSR = AuthCookieClient;
const addSecurityKeyPromise = async ({ backendUrl, interpreter }, nickname) => {
  const api = nhostApiClient(backendUrl);
  try {
    const { data: options } = await api.post("/user/webauthn/add", {}, {
      headers: {
        authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`
      }
    });
    let credential;
    try {
      credential = await startRegistration(options);
    } catch (e) {
      throw new CodifiedError(e);
    }
    const { data: key } = await api.post("/user/webauthn/verify", { credential, nickname }, {
      headers: {
        authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`
      }
    });
    return { key, isError: false, error: null, isSuccess: true };
  } catch (e) {
    const { error } = e;
    return { isError: true, error, isSuccess: false };
  }
};
const changeEmailPromise = async (interpreter, email, options) => new Promise((resolve) => {
  interpreter.send("REQUEST", {
    email,
    options
  });
  interpreter.onTransition((s) => {
    if (s.matches({ idle: "error" })) {
      resolve({ error: s.context.error, isError: true, needsEmailVerification: false });
    } else if (s.matches({ idle: "success" })) {
      resolve({ error: null, isError: false, needsEmailVerification: true });
    }
  });
});
const changePasswordPromise = async (interpreter, password, ticket) => new Promise((resolve) => {
  interpreter.send("REQUEST", {
    password,
    ticket
  });
  interpreter.onTransition((state) => {
    if (state.matches({ idle: "error" })) {
      resolve({ error: state.context.error, isError: true, isSuccess: false });
    } else if (state.matches({ idle: "success" })) {
      resolve({ error: null, isError: false, isSuccess: true });
    }
  });
});
const generateQrCodePromise = (service) => new Promise((resolve) => {
  service.send("GENERATE");
  service.onTransition((state) => {
    if (state.matches("generated")) {
      resolve({
        error: null,
        isError: false,
        isGenerated: true,
        qrCodeDataUrl: state.context.imageUrl || ""
      });
    } else if (state.matches({ idle: "error" })) {
      resolve({
        error: state.context.error || null,
        isError: true,
        isGenerated: false,
        qrCodeDataUrl: ""
      });
    }
  });
});
const activateMfaPromise = (service, code) => new Promise((resolve) => {
  service.send("ACTIVATE", {
    activeMfaType: "totp",
    code
  });
  service.onTransition((state) => {
    if (state.matches({ generated: "activated" })) {
      resolve({ error: null, isActivated: true, isError: false });
    } else if (state.matches({ generated: { idle: "error" } })) {
      resolve({ error: state.context.error, isActivated: false, isError: true });
    }
  });
});
const resetPasswordPromise = async (interpreter, email, options) => new Promise((resolve) => {
  interpreter.send("REQUEST", {
    email,
    options
  });
  interpreter.onTransition((state) => {
    if (state.matches({ idle: "error" })) {
      resolve({ error: state.context.error, isError: true, isSent: false });
    } else if (state.matches({ idle: "success" })) {
      resolve({ error: null, isError: false, isSent: true });
    }
  });
});
const sendVerificationEmailPromise = (interpreter, email, options) => new Promise((resolve) => {
  interpreter.send("REQUEST", {
    email,
    options
  });
  interpreter.onTransition((state) => {
    if (state.matches({ idle: "error" })) {
      resolve({ error: state.context.error, isError: true, isSent: false });
    } else if (state.matches({ idle: "success" })) {
      resolve({ error: null, isError: false, isSent: true });
    }
  });
});
const signInAnonymousPromise = (interpreter) => new Promise((resolve) => {
  const { changed } = interpreter.send("SIGNIN_ANONYMOUS");
  if (!changed) {
    resolve({
      isSuccess: false,
      isError: true,
      error: USER_ALREADY_SIGNED_IN,
      user: null,
      accessToken: null
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches({ authentication: "signedIn" })) {
      resolve({
        isSuccess: true,
        isError: false,
        error: null,
        user: state.context.user,
        accessToken: state.context.accessToken.value
      });
    }
    if (state.matches({ authentication: { signedOut: "failed" } })) {
      resolve({
        isSuccess: false,
        isError: true,
        error: state.context.errors.authentication || null,
        user: null,
        accessToken: null
      });
    }
  });
});
const signInEmailPasswordPromise = (interpreter, email, password) => new Promise((resolve) => {
  const { changed, context } = interpreter.send("SIGNIN_PASSWORD", {
    email,
    password
  });
  if (!changed) {
    return resolve({
      accessToken: context.accessToken.value,
      error: USER_ALREADY_SIGNED_IN,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: context.user
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    })) {
      resolve({
        accessToken: null,
        error: null,
        isError: false,
        isSuccess: false,
        needsEmailVerification: true,
        needsMfaOtp: false,
        mfa: null,
        user: null
      });
    } else if (state.matches({ authentication: { signedOut: "needsMfa" } })) {
      resolve({
        accessToken: null,
        error: null,
        isError: false,
        isSuccess: false,
        needsEmailVerification: false,
        needsMfaOtp: true,
        mfa: state.context.mfa,
        user: null
      });
    } else if (state.matches({ authentication: { signedOut: "failed" } })) {
      resolve({
        accessToken: null,
        error: state.context.errors.authentication || null,
        isError: true,
        isSuccess: false,
        needsEmailVerification: false,
        needsMfaOtp: false,
        mfa: null,
        user: null
      });
    } else if (state.matches({ authentication: "signedIn" })) {
      resolve({
        accessToken: state.context.accessToken.value,
        error: null,
        isError: false,
        isSuccess: true,
        needsEmailVerification: false,
        needsMfaOtp: false,
        mfa: null,
        user: state.context.user
      });
    }
  });
});
const signInEmailPasswordlessPromise = (interpreter, email, options) => new Promise((resolve) => {
  const { changed } = interpreter.send("PASSWORDLESS_EMAIL", {
    email,
    options
  });
  if (!changed) {
    return resolve({
      error: USER_ALREADY_SIGNED_IN,
      isError: true,
      isSuccess: false
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches("registration.incomplete.failed")) {
      resolve({
        error: state.context.errors.registration || null,
        isError: true,
        isSuccess: false
      });
    } else if (state.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    })) {
      resolve({ error: null, isError: false, isSuccess: true });
    }
  });
});
const signInEmailSecurityKeyPromise = (interpreter, email) => new Promise((resolve) => {
  const { changed, context } = interpreter.send({ type: "SIGNIN_SECURITY_KEY_EMAIL", email });
  if (!changed) {
    return resolve({
      accessToken: context.accessToken.value,
      error: USER_ALREADY_SIGNED_IN,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: context.user
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    })) {
      resolve({
        accessToken: null,
        error: null,
        isError: false,
        isSuccess: false,
        needsEmailVerification: true,
        user: null
      });
    } else if (state.matches({ authentication: { signedOut: "failed" } })) {
      resolve({
        accessToken: null,
        error: state.context.errors.authentication || null,
        isError: true,
        isSuccess: false,
        needsEmailVerification: false,
        user: null
      });
    } else if (state.matches({ authentication: "signedIn" })) {
      resolve({
        accessToken: state.context.accessToken.value,
        error: null,
        isError: false,
        isSuccess: true,
        needsEmailVerification: false,
        user: state.context.user
      });
    }
  });
});
const signInMfaTotpPromise = (interpreter, otp, ticket) => new Promise((resolve) => {
  const { changed, context } = interpreter.send("SIGNIN_MFA_TOTP", {
    otp,
    ticket
  });
  if (!changed) {
    return resolve({
      accessToken: context.accessToken.value,
      error: USER_ALREADY_SIGNED_IN,
      isError: true,
      isSuccess: false,
      user: context.user
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches({ authentication: { signedOut: "failed" } })) {
      resolve({
        accessToken: null,
        error: state.context.errors.authentication || null,
        isError: true,
        isSuccess: false,
        user: null
      });
    } else if (state.matches({ authentication: "signedIn" })) {
      resolve({
        accessToken: state.context.accessToken.value,
        error: null,
        isError: false,
        isSuccess: true,
        user: state.context.user
      });
    }
  });
});
const signInSmsPasswordlessPromise = (interpreter, phoneNumber, options) => new Promise((resolve) => {
  const { changed } = interpreter.send("PASSWORDLESS_SMS", { phoneNumber, options });
  if (!changed) {
    return resolve({
      error: USER_ALREADY_SIGNED_IN,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches("registration.incomplete.needsOtp")) {
      resolve({
        error: null,
        isError: false,
        isSuccess: false,
        needsOtp: true
      });
    } else if (state.matches("registration.incomplete.failed")) {
      resolve({
        error: state.context.errors.authentication || null,
        isError: true,
        isSuccess: false,
        needsOtp: false
      });
    }
  });
});
const signInSmsPasswordlessOtpPromise = (interpreter, phoneNumber, otp) => new Promise((resolve) => {
  const { changed } = interpreter.send({ type: "PASSWORDLESS_SMS_OTP", phoneNumber, otp });
  if (!changed) {
    return resolve({
      error: USER_ALREADY_SIGNED_IN,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches({ authentication: "signedIn" })) {
      resolve({
        error: null,
        isError: false,
        isSuccess: true,
        user: state.context.user,
        accessToken: state.context.accessToken.value
      });
    } else if (state.matches({ registration: { incomplete: "failed" } })) {
      resolve({
        error: state.context.errors.authentication || null,
        isError: true,
        isSuccess: false,
        user: null,
        accessToken: null
      });
    }
  });
});
const signOutPromise = async (interpreter, all) => new Promise((resolve) => {
  const { event } = interpreter.send("SIGNOUT", { all });
  if (event.type !== "SIGNED_OUT") {
    return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED });
  }
  interpreter.onTransition((state) => {
    if (state.matches({ authentication: { signedOut: "success" } })) {
      resolve({ isSuccess: true, isError: false, error: null });
    } else if (state.matches("authentication.signedOut.failed")) {
      resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null });
    }
  });
});
const signUpEmailPasswordPromise = (interpreter, email, password, options) => new Promise((resolve) => {
  const { changed, context } = interpreter.send("SIGNUP_EMAIL_PASSWORD", {
    email,
    password,
    options
  });
  if (!changed) {
    return resolve({
      error: USER_ALREADY_SIGNED_IN,
      accessToken: context.accessToken.value,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: context.user
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches("registration.incomplete.failed")) {
      resolve({
        accessToken: null,
        error: state.context.errors.registration || null,
        isError: true,
        isSuccess: false,
        needsEmailVerification: false,
        user: null
      });
    } else if (state.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    })) {
      resolve({
        accessToken: null,
        error: null,
        isError: false,
        isSuccess: false,
        needsEmailVerification: true,
        user: null
      });
    } else if (state.matches({ authentication: "signedIn", registration: "complete" })) {
      resolve({
        accessToken: state.context.accessToken.value,
        error: null,
        isError: false,
        isSuccess: true,
        needsEmailVerification: false,
        user: state.context.user
      });
    }
  });
});
const signUpEmailSecurityKeyPromise = (interpreter, email, options) => new Promise((resolve) => {
  const { changed, context } = interpreter.send("SIGNUP_SECURITY_KEY", {
    email,
    options
  });
  if (!changed) {
    return resolve({
      error: USER_ALREADY_SIGNED_IN,
      accessToken: context.accessToken.value,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: context.user
    });
  }
  interpreter.onTransition((state) => {
    if (state.matches("registration.incomplete.failed")) {
      resolve({
        accessToken: null,
        error: state.context.errors.registration || null,
        isError: true,
        isSuccess: false,
        needsEmailVerification: false,
        user: null
      });
    } else if (state.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    })) {
      resolve({
        accessToken: null,
        error: null,
        isError: false,
        isSuccess: false,
        needsEmailVerification: true,
        user: null
      });
    } else if (state.matches({ authentication: "signedIn", registration: "complete" })) {
      resolve({
        accessToken: state.context.accessToken.value,
        error: null,
        isError: false,
        isSuccess: true,
        needsEmailVerification: false,
        user: state.context.user
      });
    }
  });
});
export { AuthClient, AuthClientSSR, AuthCookieClient, CodifiedError, EMAIL_NEEDS_VERIFICATION, INVALID_EMAIL_ERROR, INVALID_MFA_CODE_ERROR, INVALID_MFA_TICKET_ERROR, INVALID_MFA_TYPE_ERROR, INVALID_PASSWORD_ERROR, INVALID_PHONE_NUMBER_ERROR, INVALID_REFRESH_TOKEN, MIN_PASSWORD_LENGTH, NETWORK_ERROR_CODE, NHOST_JWT_EXPIRES_AT_KEY, NHOST_REFRESH_TOKEN_KEY, NO_MFA_TICKET_ERROR, NO_REFRESH_TOKEN, OTHER_ERROR_CODE, REFRESH_TOKEN_RETRY_INTERVAL, REFRESH_TOKEN_RETRY_MAX_ATTEMPTS, STATE_ERROR_CODE, TOKEN_REFRESHER_RUNNING_ERROR, TOKEN_REFRESH_MARGIN, USER_ALREADY_SIGNED_IN, USER_NOT_ANONYMOUS, USER_UNAUTHENTICATED, VALIDATION_ERROR_CODE, activateMfaPromise, addSecurityKeyPromise, changeEmailPromise, changePasswordPromise, createAuthMachine, createChangeEmailMachine, createChangePasswordMachine, createEnableMfaMachine, createResetPasswordMachine, createSendVerificationEmailMachine, encodeQueryParameters, generateQrCodePromise, getParameterByName, localStorageGetter, localStorageSetter, removeParameterFromWindow, resetPasswordPromise, rewriteRedirectTo, sendVerificationEmailPromise, signInAnonymousPromise, signInEmailPasswordPromise, signInEmailPasswordlessPromise, signInEmailSecurityKeyPromise, signInMfaTotpPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signOutPromise, signUpEmailPasswordPromise, signUpEmailSecurityKeyPromise };
//# sourceMappingURL=index.esm.js.map
