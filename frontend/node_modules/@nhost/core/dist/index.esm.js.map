{"version":3,"file":"index.esm.js","sources":["../../../node_modules/.pnpm/@simplewebauthn+browser@6.0.0/node_modules/@simplewebauthn/browser/dist/bundle/index.js","../src/constants.ts","../src/errors.ts","../src/hasura-auth.ts","../src/storage.ts","../src/utils.ts","../src/validators.ts","../src/machines/context.ts","../src/machines/change-email.ts","../src/machines/change-password.ts","../src/machines/enable-mfa.ts","../src/machines/reset-password.ts","../src/machines/send-verification-email.ts","../src/machines/index.ts","../src/client.ts","../src/cookie-client.ts","../src/promises/addSecurityKey.ts","../src/promises/changeEmail.ts","../src/promises/changePassword.ts","../src/promises/mfa.ts","../src/promises/resetPassword.ts","../src/promises/sendVerificationEmail.ts","../src/promises/signInAnonymous.ts","../src/promises/signInEmailPassword.ts","../src/promises/signInEmailPasswordless.ts","../src/promises/signInEmailSecurityKey.ts","../src/promises/signInMfaTotp.ts","../src/promises/signInSmsPasswordless.ts","../src/promises/signInSmsPasswordlessOtp.ts","../src/promises/signOut.ts","../src/promises/signUpEmailPassword.ts","../src/promises/signUpEmailSecurityKey.ts"],"sourcesContent":["/* [@simplewebauthn/browser@6.0.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort();\n        }\n        this.controller = new AbortController();\n        return this.controller.signal;\n    }\n    reset() {\n        this.controller = undefined;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    const credentialJSON = {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n    if (typeof response.getTransports === 'function') {\n        credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    if (navigator.credentials.conditionalMediationSupported) {\n        return true;\n    }\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    var _a;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n            return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n        }\n        return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN = 300 // five minutes\n\n/** Number of seconds before retrying a token refresh after an error */\nexport const REFRESH_TOKEN_RETRY_INTERVAL = 5\n\n// TODO not yet implemented\n// TODO try when offline for a long time: maybe we could keep state as 'signedIn'\n/** Maximum number of attempts to refresh a token before stopping the timer and logging out */\nexport const REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30\n","export const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\nexport type ErrorPayload = {\n  error: string\n  status: number\n  message: string\n}\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: ErrorPayload\n  constructor(original: Error | ErrorPayload) {\n    super(original.message)\n    Error.captureStackTrace(this, this.constructor)\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationErrorPayload = ErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n","import axios, { AxiosError } from 'axios'\n\nimport { ErrorPayload, NETWORK_ERROR_CODE } from './errors'\n\nexport const nhostApiClient = (backendUrl: string) => {\n  const client = axios.create({ baseURL: backendUrl })\n\n  client.interceptors.response.use(\n    (response) => response,\n    (error: AxiosError<{ message: string; error?: string; statusCode?: number }>) =>\n      Promise.reject<{ error: ErrorPayload }>({\n        error: {\n          message:\n            error.response?.data?.message ??\n            error.message ??\n            error.request.responseText ??\n            JSON.stringify(error),\n          status: error.response?.status ?? error.response?.data.statusCode ?? NETWORK_ERROR_CODE,\n          error: error.response?.data.error || error.request.statusText || 'network'\n        }\n      })\n  )\n  return client\n}\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType } from './types'\nexport type StorageGetter = (key: string) => string | null | Promise<string | null>\nexport type StorageSetter = (key: string, value: string | null) => void | Promise<void>\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30 })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { RedirectOption } from './types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from './constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import type { ErrorPayload } from '../errors'\nimport { User } from '../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n  }\n  errors: Partial<Record<StateErrorTypes, ErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type ChangeEmailContext = {\n  error: ErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await api.post(\n            '/user/email/change',\n            {\n              newEmail: email,\n              options: rewriteRedirectTo(clientUrl, options)\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_PASSWORD_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangePasswordResponse } from '../types'\nimport { isValidPassword } from '../validators'\n\nexport type ChangePasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          api.post<string, ChangePasswordResponse>(\n            '/user/password',\n            { newPassword: password, ticket: ticket },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\n\nexport type EnableMfaContext = {\n  error: ErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: ErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating'\n          },\n          states: {\n            initial: {},\n            error: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ]\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await api.get('/mfa/totp/generate', {\n            headers: {\n              authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n            }\n          })\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          api.post(\n            '/user/mfa',\n            {\n              code,\n              activeMfaType\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type ResetPasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          api.post<string, ResetPasswordResponse>('/user/password/reset', {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { SendVerificationEmailOptions, SendVerificationEmailResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type SendVerificationEmailContext = {\n  error: ErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await api.post<SendVerificationEmailResponse>(\n            '/user/email/send-verification-email',\n            {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import type { AxiosRequestConfig } from 'axios'\nimport { assign, createMachine, send } from 'xstate'\n\nimport { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\n\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_RETRY_INTERVAL,\n  TOKEN_REFRESH_MARGIN\n} from '../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE,\n  ValidationErrorPayload\n} from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { localStorageGetter, localStorageSetter } from '../storage'\nimport {\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInMfaTotpResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse\n} from '../types'\nimport { getParameterByName, removeParameterFromWindow, rewriteRedirectTo } from '../utils'\nimport { isValidEmail, isValidPassword, isValidPhoneNumber, isValidTicket } from '../validators'\n\nimport { AuthContext, INITIAL_MACHINE_CONTEXT, StateErrorTypes } from './context'\nimport { AuthEvents } from './events'\n\nexport * from './change-email'\nexport * from './change-password'\nexport * from './enable-mfa'\nexport * from './reset-password'\nexport * from './send-verification-email'\n\nexport type { AuthContext, AuthEvents, StateErrorTypes }\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  clientStorageGetter,\n  clientStorageSetter,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage)\n  const api = nhostApiClient(backendUrl)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    config?: AxiosRequestConfig<D>\n  ): Promise<T> => {\n    const result = await api.post(url, data, config)\n\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./index.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      preserveActionOrder: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              entry: 'resetErrors',\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: 'signedIn'\n                },\n                onError: { actions: ['saveAuthenticationError'], target: 'signedOut' }\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptRefreshToken'],\n                  exit: ['destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        {\n                          cond: 'hasRefreshToken',\n                          target: 'running'\n                        }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                              target: 'pending'\n                            },\n                            onError: [\n                              { actions: 'saveRefreshAttempt', target: 'pending' }\n                              // ? stop trying after x attempts?\n                              // {\n                              //   actions: 'retry',\n                              //   cond: 'canRetry',\n                              //   target: 'pending'\n                              // },\n                              // {\n                              //   actions: ['sendError', 'resetToken'],\n                              //   target: '#timer.stopped'\n                              // }\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            refreshToken: { value }\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n            return { value: refreshToken }\n          }\n        }),\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({})\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the token to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn) {\n            try {\n              const channel = new BroadcastChannel('nhost')\n              // ? broadcat session instead of token ?\n              channel.postMessage(context.refreshToken.value)\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n          if (!expiresAt) {\n            return false\n          }\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If a refesh previously failed, only try to refresh every `REFRESH_TOKEN_RETRY_INTERVAL` seconds\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1_000\n          }\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refershed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN seconds before the JWT exprires\n          const expiresIn = expiresAt.getTime() - Date.now()\n          const remaining = expiresIn - 1_000 * TOKEN_REFRESH_MARGIN\n          return remaining <= 0\n        },\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          return { session, error: null }\n        },\n        signout: (ctx, e) =>\n          postRequest('/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          }),\n        signUpEmailPassword: async (context, { email, password, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest<SignUpResponse>('/signup/email-password', {\n              email,\n              password,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signUpSecurityKey: async (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options }\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname\n            }\n          })\n        },\n        importRefreshToken: async () => {\n          let error: ValidationErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: ValidationErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              if (error) {\n                return Promise.reject<NhostSessionResponse>({\n                  session: null,\n                  error: {\n                    status: VALIDATION_ERROR_CODE,\n                    error,\n                    message: getParameterByName('errorDescription') || error\n                  }\n                })\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: ValidationErrorPayload }).error\n            }\n          }\n          return Promise.reject<NhostSessionResponse>({ error })\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\n\nimport { AuthMachine, AuthMachineOptions, createAuthMachine } from './machines'\nimport type { AuthInterpreter } from './types'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  readonly machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _channel?: BroadcastChannel\n  private _subscriptions: Set<(client: AuthClient) => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this.machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.interpreter = interpret(this.machine, { devTools })\n      this.interpreter.start()\n    }\n\n    if (typeof window !== 'undefined' && autoSignIn) {\n      try {\n        // TODO listen to sign out\n        // TODO the same refresh token is used and refreshed by all tabs\n        // * Ideally, a single tab should autorefresh and share the new jwt\n        this._channel = new BroadcastChannel('nhost')\n        this._channel.addEventListener('message', (token) => {\n          const existingToken = this.interpreter?.state.context.refreshToken.value\n          if (this.interpreter && token.data !== existingToken) {\n            this.interpreter.send('TRY_TOKEN', { token: token.data })\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n  set interpreter(interpreter: AuthInterpreter | undefined) {\n    this._interpreter = interpreter\n    if (interpreter) {\n      this._subscriptions.forEach((fn) => fn(this))\n    }\n  }\n\n  onStart(fn: (client: AuthClient) => void) {\n    if (this.interpreter) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      fn(this)\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptions.add(fn)\n    }\n  }\n}\n","import { AuthClient, NhostClientOptions } from './client'\nconst isBrowser = typeof window !== 'undefined'\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser && options.autoSignIn,\n      autoRefreshToken: isBrowser && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\n\nimport { AuthClient } from '../client'\nimport { CodifiedError, ErrorPayload } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { SecurityKey } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\nexport interface AddSecurityKeyHandlerResult extends ActionErrorState, ActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, ActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  const api = nhostApiClient(backendUrl)\n  try {\n    const { data: options } = await api.post<PublicKeyCredentialCreationOptionsJSON>(\n      '/user/webauthn/add',\n      {},\n      {\n        headers: {\n          authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n        }\n      }\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await api.post<SecurityKey>(\n      '/user/webauthn/verify',\n      { credential, nickname },\n      {\n        headers: {\n          authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n        }\n      }\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: ErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult extends ActionErrorState, NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, ActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, ActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends ActionErrorState, ActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password, ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { ActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends ActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\nexport interface ActivateMfaHandlerResult extends ActionErrorState {\n  isActivated: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || ''\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: ''\n        })\n      }\n    })\n  })\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends ActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, ActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends ActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends ActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState extends SignInAnonymousHandlerResult, ActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, PasswordlessOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends ActionErrorState,\n    ActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, ActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, PasswordlessOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult extends ActionErrorState, ActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    ActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends ActionErrorState, ActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, ActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, SignUpOptions } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    ActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    ActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n"],"names":["isBrowser"],"mappings":"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"}