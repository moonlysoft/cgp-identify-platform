var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { NhostClient as NhostClient$1 } from "@nhost/nhost-js";
import produce from "immer";
import React, { createContext, useRef, useEffect, useContext, useState, useMemo, useCallback } from "react";
import { useInterpret, useSelector } from "@xstate/react";
import { addSecurityKeyPromise, createChangeEmailMachine, changeEmailPromise, createChangePasswordMachine, changePasswordPromise, createEnableMfaMachine, generateQrCodePromise, activateMfaPromise, encodeQueryParameters, rewriteRedirectTo, createResetPasswordMachine, resetPasswordPromise, createSendVerificationEmailMachine, sendVerificationEmailPromise, signInAnonymousPromise, signInEmailPasswordPromise, signInMfaTotpPromise, signInEmailPasswordlessPromise, signInEmailSecurityKeyPromise, signInSmsPasswordlessPromise, signInSmsPasswordlessOtpPromise, signOutPromise, signUpEmailPasswordPromise, signUpEmailSecurityKeyPromise } from "@nhost/core";
import jwt_decode from "jwt-decode";
import { createFileUploadMachine, uploadFilePromise, createMultipleFilesUploadMachine, uploadMultipleFilesPromise } from "@nhost/hasura-storage-js";
class NhostClient extends NhostClient$1 {
  constructor(params) {
    super(__spreadProps(__spreadValues({}, params), { start: false }));
  }
}
const NhostReactContext = createContext({});
const NhostReactProvider = (_a) => {
  var _b = _a, {
    nhost,
    initial
  } = _b, props = __objRest(_b, [
    "nhost",
    "initial"
  ]);
  const machine = nhost.auth.client.machine;
  const interpreter = useInterpret(machine, {
    devTools: nhost.devTools,
    context: produce(machine.context, (ctx) => {
      var _a2, _b2;
      if (initial) {
        ctx.user = initial.user;
        ctx.refreshToken.value = (_a2 = initial.refreshToken) != null ? _a2 : null;
        ctx.accessToken.value = (_b2 = initial.accessToken) != null ? _b2 : null;
        ctx.accessToken.expiresAt = new Date(Date.now() + initial.accessTokenExpiresIn * 1e3);
      }
    })
  }).start();
  const isInitialMount = useRef(true);
  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
    } else {
      if (initial) {
        interpreter.send("SESSION_UPDATE", { data: { session: initial } });
      }
    }
  }, [initial, interpreter]);
  nhost.auth.client.interpreter = interpreter;
  return /* @__PURE__ */ React.createElement(NhostReactContext.Provider, {
    value: nhost
  }, props.children);
};
const useAuthInterpreter = () => {
  var _a;
  const nhost = useContext(NhostReactContext);
  const interpreter = (_a = nhost.auth) == null ? void 0 : _a.client.interpreter;
  if (!interpreter)
    throw Error("No interpreter");
  return interpreter;
};
const useAccessToken = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => state.context.accessToken.value);
};
const useNhostClient = () => {
  const nhost = useContext(NhostReactContext);
  return nhost;
};
const useAddSecurityKey = () => {
  const nhost = useNhostClient();
  const [error, setError] = useState(null);
  const isSuccess = !error;
  const isError = !!error;
  const [isLoading, setIsLoading] = useState(false);
  const add = async (nickname) => {
    setIsLoading(true);
    const result = await addSecurityKeyPromise(nhost.auth.client, nickname);
    const { error: error2 } = result;
    if (error2) {
      setError(error2);
    }
    setIsLoading(false);
    return result;
  };
  return { add, isLoading, isSuccess, isError, error };
};
const useAuthenticated = () => {
  const service = useAuthInterpreter();
  const [isAuthenticated, setIsAuthenticated] = useState(!!service.status && service.state.matches({ authentication: "signedIn" }));
  useEffect(() => {
    const subscription = service.subscribe((state) => {
      const newValue = state.matches({ authentication: "signedIn" });
      setIsAuthenticated(newValue);
    });
    return subscription.unsubscribe;
  }, [service]);
  return isAuthenticated;
};
const useAuthenticationStatus = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => ({
    isAuthenticated: state.matches({ authentication: "signedIn" }),
    isLoading: state.hasTag("loading"),
    error: state.context.errors.authentication || null,
    isError: state.matches({ authentication: { signedOut: "failed" } })
  }), (a, b) => a.isAuthenticated === b.isAuthenticated && a.isLoading === b.isLoading);
};
const useAuthLoading = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => state.hasTag("loading"));
};
function useChangeEmail(a, b) {
  const stateEmail = useMemo(() => typeof a === "string" ? a : void 0, [a]);
  const stateOptions = useMemo(() => typeof a !== "string" ? a : b, [a, b]);
  const nhost = useNhostClient();
  const machine = useMemo(() => createChangeEmailMachine(nhost.auth.client), [nhost]);
  const service = useInterpret(machine);
  const isLoading = useSelector(service, (s) => s.matches("requesting"));
  const error = useSelector(service, (state) => state.context.error);
  const isError = useSelector(service, (state) => state.matches("idle.error"));
  const needsEmailVerification = useSelector(service, (state) => state.matches("idle.success"));
  const changeEmail = useCallback(async (valueEmail, valueOptions = stateOptions) => changeEmailPromise(service, typeof valueEmail === "string" ? valueEmail : stateEmail, valueOptions), [service, stateEmail, stateOptions]);
  return { changeEmail, isLoading, needsEmailVerification, isError, error };
}
const useChangePassword = (statePassword) => {
  const nhost = useNhostClient();
  const machine = useMemo(() => createChangePasswordMachine(nhost.auth.client), [nhost]);
  const service = useInterpret(machine);
  const isError = useSelector(service, (state) => state.matches({ idle: "error" }));
  const isSuccess = useSelector(service, (state) => state.matches({ idle: "success" }));
  const error = useSelector(service, (state) => state.context.error);
  const isLoading = useSelector(service, (state) => state.matches("requesting"));
  const changePassword = (valuePassword) => changePasswordPromise(service, typeof valuePassword === "string" ? valuePassword : statePassword);
  return { changePassword, isLoading, isSuccess, isError, error };
};
const useConfigMfa = () => {
  const nhost = useNhostClient();
  const machine = useMemo(() => createEnableMfaMachine(nhost.auth.client), [nhost]);
  const service = useInterpret(machine);
  const isError = useSelector(service, (state) => state.matches({ idle: "error" }) || state.matches({ generated: { idle: "error" } }));
  const isGenerating = useSelector(service, (state) => state.matches("generating"));
  const isGenerated = useSelector(service, (state) => state.matches("generated"));
  const isActivating = useSelector(service, (state) => state.matches({ generated: "activating" }));
  const isActivated = useSelector(service, (state) => state.matches({ generated: "activated" }));
  const error = useSelector(service, (state) => state.context.error);
  const qrCodeDataUrl = useSelector(service, (state) => state.context.imageUrl || "");
  const generateQrCode = () => generateQrCodePromise(service);
  const activateMfa = (code) => activateMfaPromise(service, code);
  return {
    generateQrCode,
    isGenerating,
    qrCodeDataUrl,
    isGenerated,
    activateMfa,
    isActivating,
    isActivated,
    isError,
    error
  };
};
const useDecodedAccessToken = () => {
  const jwt = useAccessToken();
  return jwt ? jwt_decode(jwt) : null;
};
const useFileUploadItem = (ref) => {
  const nhost = useNhostClient();
  const add = (params) => {
    ref.send({
      type: "ADD",
      file: params.file,
      bucketId: params.bucketId || bucketId
    });
  };
  const upload = (params) => uploadFilePromise(nhost, ref, {
    file: params.file,
    bucketId: params.bucketId || bucketId,
    id,
    name
  });
  const cancel = () => {
    ref.send("CANCEL");
  };
  const destroy = () => {
    ref.send("DESTROY");
  };
  const isUploading = useSelector(ref, (state) => state.matches("uploading"));
  const isUploaded = useSelector(ref, (state) => state.matches("uploaded"));
  const isError = useSelector(ref, (state) => state.matches("error"));
  const error = useSelector(ref, (state) => state.context.error || null);
  const progress = useSelector(ref, (state) => state.context.progress);
  const id = useSelector(ref, (state) => state.context.id);
  const bucketId = useSelector(ref, (state) => state.context.bucketId);
  const name = useSelector(ref, (state) => {
    var _a;
    return (_a = state.context.file) == null ? void 0 : _a.name;
  });
  return {
    add,
    upload,
    cancel,
    destroy,
    isUploaded,
    isUploading,
    isError,
    error,
    progress,
    id,
    bucketId,
    name
  };
};
const useFileUpload = () => {
  const service = useInterpret(createFileUploadMachine);
  return useFileUploadItem(service);
};
const useHasuraClaims = () => {
  const claims = useDecodedAccessToken();
  return (claims == null ? void 0 : claims["https://hasura.io/jwt/claims"]) || null;
};
const useHasuraClaim = (name) => {
  const hasuraClaims = useHasuraClaims();
  return (hasuraClaims == null ? void 0 : hasuraClaims[name.startsWith("x-hasura-") ? name : `x-hasura-${name}`]) || null;
};
const useMultipleFilesUpload = () => {
  const nhost = useNhostClient();
  const [errors, setErrors] = useState([]);
  const service = useInterpret(createMultipleFilesUploadMachine, {}, (state) => {
    if (state.event.type === "UPLOAD_ERROR") {
      setErrors(state.context.files.filter((ref) => {
        var _a;
        return (_a = ref.getSnapshot()) == null ? void 0 : _a.context.error;
      }));
    } else if ((state.matches("uploaded") || state.event.type === "CLEAR") && errors.length > 0) {
      setErrors([]);
    }
  });
  const add = (params) => {
    service.send(__spreadValues({ type: "ADD" }, params));
  };
  const upload = (params) => uploadMultipleFilesPromise(nhost, service, params);
  const cancel = () => {
    service.send("CANCEL");
  };
  const clear = () => {
    service.send("CLEAR");
  };
  const isUploading = useSelector(service, (state) => state.matches("uploading"));
  const isUploaded = useSelector(service, (state) => state.matches("uploaded"));
  const isError = useSelector(service, (state) => state.matches("error"));
  const progress = useSelector(service, (state) => state.context.progress);
  const files = useSelector(service, (state) => state.context.files);
  return {
    upload,
    add,
    clear,
    cancel,
    progress,
    isUploaded,
    isUploading,
    files,
    isError,
    errors
  };
};
const useUserData = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => state.context.user, (a, b) => (a && JSON.stringify(a)) === (b && JSON.stringify(b)));
};
const useNhostAuth = () => {
  const { isLoading, isAuthenticated } = useAuthenticationStatus();
  const user = useUserData();
  return useMemo(() => ({ isLoading, isAuthenticated, user }), [isLoading, isAuthenticated, user]);
};
const useNhostBackendUrl = () => {
  const nhost = useContext(NhostReactContext);
  return nhost.auth.client.backendUrl.replace("/v1/auth", "");
};
const useProviderLink = (options) => {
  const [isSSR, setIsSSR] = useState(true);
  useEffect(() => {
    setIsSSR(false);
  }, []);
  const nhost = useContext(NhostReactContext);
  return new Proxy({}, {
    get(_, provider) {
      return encodeQueryParameters(`${nhost.auth.client.backendUrl}/signin/provider/${provider}`, rewriteRedirectTo(isSSR ? void 0 : nhost.auth.client.clientUrl, options));
    }
  });
};
const useResetPassword = (a, b) => {
  const stateEmail = typeof a === "string" ? a : void 0;
  const stateOptions = typeof a !== "string" ? a : b;
  const nhost = useNhostClient();
  const machine = useMemo(() => createResetPasswordMachine(nhost.auth.client), [nhost]);
  const service = useInterpret(machine);
  const isLoading = useSelector(service, (s) => s.matches("requesting"));
  const error = useSelector(service, (state) => state.context.error);
  const isError = useSelector(service, (state) => state.matches("idle.error"));
  const isSent = useSelector(service, (state) => state.matches("idle.success"));
  const resetPassword = (valueEmail, valueOptions = stateOptions) => resetPasswordPromise(service, typeof valueEmail === "string" ? valueEmail : stateEmail, valueOptions);
  return { resetPassword, isLoading, isSent, isError, error };
};
const useSendVerificationEmail = (a, b) => {
  const stateEmail = typeof a === "string" ? a : void 0;
  const stateOptions = typeof a !== "string" ? a : b;
  const nhost = useNhostClient();
  const machine = useMemo(() => createSendVerificationEmailMachine(nhost.auth.client), [nhost]);
  const service = useInterpret(machine);
  const isError = useSelector(service, (state) => state.matches({ idle: "error" }));
  const isSent = useSelector(service, (state) => state.matches({ idle: "success" }));
  const error = useSelector(service, (state) => state.context.error);
  const isLoading = useSelector(service, (state) => state.matches("requesting"));
  const sendEmail = (valueEmail, valueOptions = stateOptions) => sendVerificationEmailPromise(service, typeof valueEmail === "string" ? valueEmail : stateEmail, valueOptions);
  return { sendEmail, isLoading, isSent, isError, error };
};
const useSignInAnonymous = () => {
  const service = useAuthInterpreter();
  const signInAnonymous = () => signInAnonymousPromise(service);
  const error = useSelector(service, (state) => state.context.errors.authentication || null, (a, b) => (a == null ? void 0 : a.error) === (b == null ? void 0 : b.error));
  const isLoading = useSelector(service, (state) => state.matches({ authentication: { authenticating: "anonymous" } }));
  const isSuccess = useSelector(service, (state) => state.matches({
    authentication: "signedIn"
  }));
  const isError = useSelector(service, (state) => state.matches({ authentication: { signedOut: "failed" } }));
  const user = useSelector(service, (state) => state.context.user, (a, b) => (a == null ? void 0 : a.id) === (b == null ? void 0 : b.id));
  const accessToken = useSelector(service, (state) => state.context.accessToken.value);
  return { accessToken, error, isError, isLoading, isSuccess, signInAnonymous, user };
};
const useSignInEmailPassword = (stateEmail, statePassword, stateOtp) => {
  const service = useAuthInterpreter();
  const signInEmailPassword = (valueEmail, valuePassword) => signInEmailPasswordPromise(service, typeof valueEmail === "string" ? valueEmail : stateEmail, typeof valuePassword === "string" ? valuePassword : statePassword);
  const sendMfaOtp = (valueOtp) => signInMfaTotpPromise(service, typeof valueOtp === "string" ? valueOtp : stateOtp);
  const user = useSelector(service, (state) => state.context.user, (a, b) => (a == null ? void 0 : a.id) === (b == null ? void 0 : b.id));
  const accessToken = useSelector(service, (state) => state.context.accessToken.value);
  const error = useSelector(service, (state) => state.context.errors.authentication || null, (a, b) => (a == null ? void 0 : a.error) === (b == null ? void 0 : b.error));
  const isSuccess = useSelector(service, (state) => state.matches({
    authentication: "signedIn"
  }));
  const isLoading = useSelector(service, (state) => state.matches({ authentication: { authenticating: "password" } }), (a, b) => a === b);
  const needsEmailVerification = useSelector(service, (state) => state.matches({
    authentication: { signedOut: "noErrors" },
    registration: { incomplete: "needsEmailVerification" }
  }), (a, b) => a === b);
  const needsMfaOtp = useSelector(service, (state) => state.matches({ authentication: { signedOut: "needsMfa" } }), (a, b) => a === b);
  const isError = useSelector(service, (state) => state.matches({ authentication: { signedOut: "failed" } }), (a, b) => a === b);
  const mfa = useSelector(service, (state) => state.context.mfa);
  return {
    accessToken,
    error,
    isError,
    isLoading,
    isSuccess,
    needsEmailVerification,
    needsMfaOtp,
    mfa,
    sendMfaOtp,
    signInEmailPassword,
    user
  };
};
function useSignInEmailPasswordless(a, b) {
  const stateEmail = typeof a === "string" ? a : void 0;
  const stateOptions = typeof a === "string" ? b : a;
  const service = useAuthInterpreter();
  const signInEmailPasswordless = (valueEmail, valueOptions = stateOptions) => signInEmailPasswordlessPromise(service, typeof valueEmail === "string" ? valueEmail : stateEmail, valueOptions);
  const error = useSelector(service, (state) => state.context.errors.registration || null, (a2, b2) => (a2 == null ? void 0 : a2.error) === (b2 == null ? void 0 : b2.error));
  const isLoading = useSelector(service, (state) => state.matches("registration.passwordlessEmail"));
  const isSuccess = useSelector(service, (state) => state.matches("registration.incomplete.needsEmailVerification"));
  const isError = useSelector(service, (state) => state.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless, isLoading, isSuccess, isError, error };
}
const useSignInEmailSecurityKey = () => {
  const service = useAuthInterpreter();
  const signInEmailSecurityKey = (email) => signInEmailSecurityKeyPromise(service, email);
  const user = useSelector(service, (state) => state.context.user, (a, b) => (a == null ? void 0 : a.id) === (b == null ? void 0 : b.id));
  const accessToken = useSelector(service, (state) => state.context.accessToken.value);
  const error = useSelector(service, (state) => state.context.errors.authentication || null, (a, b) => (a == null ? void 0 : a.error) === (b == null ? void 0 : b.error));
  const isSuccess = useSelector(service, (state) => state.matches({
    authentication: "signedIn"
  }));
  const isLoading = useSelector(service, (state) => state.matches({ authentication: { authenticating: "securityKeyEmail" } }), (a, b) => a === b);
  const needsEmailVerification = useSelector(service, (state) => state.matches({
    authentication: { signedOut: "noErrors" },
    registration: { incomplete: "needsEmailVerification" }
  }), (a, b) => a === b);
  const isError = useSelector(service, (state) => state.matches({ authentication: { signedOut: "failed" } }), (a, b) => a === b);
  return {
    accessToken,
    error,
    isError,
    isLoading,
    isSuccess,
    needsEmailVerification,
    signInEmailSecurityKey,
    user
  };
};
function useSignInSmsPasswordless(stateOptions) {
  const service = useAuthInterpreter();
  const [_phoneNumber, setPhoneNumber] = useState("");
  const signInSmsPasswordless = (phoneNumber, valueOptions = stateOptions) => {
    setPhoneNumber(phoneNumber);
    return signInSmsPasswordlessPromise(service, phoneNumber, valueOptions);
  };
  const sendOtp = async (...args) => {
    if (args.length === 2) {
      const [phoneNumber, code2] = args;
      return signInSmsPasswordlessOtpPromise(service, phoneNumber, code2);
    }
    const [code] = args;
    return signInSmsPasswordlessOtpPromise(service, _phoneNumber, code);
  };
  const error = useSelector(service, (state) => state.context.errors.registration || null, (a, b) => (a == null ? void 0 : a.error) === (b == null ? void 0 : b.error));
  const isLoading = useSelector(service, (state) => state.matches("registration.passwordlessSms") || state.matches("registration.passwordlessSmsOtp"));
  const isSuccess = useSelector(service, (state) => state.matches("authentication.signedIn"));
  const needsOtp = useSelector(service, (state) => state.matches("registration.incomplete.needsOtp"));
  const isError = useSelector(service, (state) => state.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless, sendOtp, isLoading, isSuccess, needsOtp, isError, error };
}
const useSignOut = (stateAll = false) => {
  const service = useAuthInterpreter();
  const signOut = (valueAll) => signOutPromise(service, typeof valueAll === "boolean" ? valueAll : stateAll);
  const isSuccess = useSelector(service, (state) => state.matches({ authentication: { signedOut: "success" } }), (a, b) => a === b);
  const error = useSelector(service, (state) => state.context.errors.signout || null, (a, b) => (a == null ? void 0 : a.error) === (b == null ? void 0 : b.error));
  return { signOut, isSuccess, error };
};
const useSignUpEmailPassword = (a, b, c) => {
  const stateEmail = typeof a === "string" ? a : void 0;
  const statePassword = typeof b === "string" ? b : void 0;
  const stateOptions = c || (typeof a !== "string" ? a : void 0);
  const service = useAuthInterpreter();
  const isError = useSelector(service, (state) => !!state.context.errors.registration);
  const error = useSelector(service, (state) => state.context.errors.registration || null, (a2, b2) => (a2 == null ? void 0 : a2.error) === (b2 == null ? void 0 : b2.error));
  const isLoading = useSelector(service, (state) => state.matches("registration.emailPassword"));
  const needsEmailVerification = useSelector(service, (state) => state.matches("registration.incomplete.needsEmailVerification"));
  const isSuccess = useSelector(service, (state) => state.matches({
    authentication: "signedIn",
    registration: "complete"
  }));
  const signUpEmailPassword = (valueEmail, valuePassword = statePassword, valueOptions = stateOptions) => signUpEmailPasswordPromise(service, typeof valueEmail === "string" ? valueEmail : stateEmail, valuePassword, valueOptions);
  const user = useSelector(service, (state) => state.context.user, (a2, b2) => (a2 == null ? void 0 : a2.id) === (b2 == null ? void 0 : b2.id));
  const accessToken = useSelector(service, (state) => state.context.accessToken.value);
  return {
    accessToken,
    error,
    isError,
    isLoading,
    isSuccess,
    needsEmailVerification,
    signUpEmailPassword,
    user
  };
};
const useSignUpEmailSecurityKeyEmail = (hookOptions) => {
  const service = useAuthInterpreter();
  const isError = useSelector(service, (state) => !!state.context.errors.registration);
  const error = useSelector(service, (state) => state.context.errors.registration || null, (a, b) => (a == null ? void 0 : a.error) === (b == null ? void 0 : b.error));
  const isLoading = useSelector(service, (state) => state.matches("registration.securityKey"));
  const needsEmailVerification = useSelector(service, (state) => state.matches("registration.incomplete.needsEmailVerification"));
  const isSuccess = useSelector(service, (state) => state.matches({
    authentication: "signedIn",
    registration: "complete"
  }));
  const signUpEmailSecurityKey = (email, options = hookOptions) => signUpEmailSecurityKeyPromise(service, email, options);
  const user = useSelector(service, (state) => state.context.user, (a, b) => (a == null ? void 0 : a.id) === (b == null ? void 0 : b.id));
  const accessToken = useSelector(service, (state) => state.context.accessToken.value);
  return {
    accessToken,
    error,
    isError,
    isLoading,
    isSuccess,
    needsEmailVerification,
    signUpEmailSecurityKey,
    user
  };
};
const useUserAvatarUrl = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.avatarUrl;
  }, (a, b) => a === b);
};
const useAvatarUrl = useUserAvatarUrl;
const useUserDefaultRole = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.defaultRole;
  }, (a, b) => a === b);
};
const useDefaultRole = useUserDefaultRole;
const useUserDisplayName = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.displayName;
  }, (a, b) => a === b);
};
const useDisplayName = useUserDisplayName;
const useUserEmail = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.email;
  }, (a, b) => a === b);
};
const useEmail = useUserEmail;
const useUserId = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.id;
  }, (a, b) => a === b);
};
const useUserIsAnonymous = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.isAnonymous;
  }, (a, b) => a === b);
};
const useIsAnonymous = useUserIsAnonymous;
const useUserLocale = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return (_a = state.context.user) == null ? void 0 : _a.locale;
  }, (a, b) => a === b);
};
const useUserRoles = () => {
  const service = useAuthInterpreter();
  return useSelector(service, (state) => {
    var _a;
    return ((_a = state.context.user) == null ? void 0 : _a.roles) || [];
  }, (a, b) => a.every((i) => b.includes(i) && b.every((i2) => a.includes(i2))));
};
export { NhostClient, NhostReactContext, NhostReactProvider, useAccessToken, useAddSecurityKey, useAuthInterpreter, useAuthLoading, useAuthenticated, useAuthenticationStatus, useAvatarUrl, useChangeEmail, useChangePassword, useConfigMfa, useDecodedAccessToken, useDefaultRole, useDisplayName, useEmail, useFileUpload, useFileUploadItem, useHasuraClaim, useHasuraClaims, useIsAnonymous, useMultipleFilesUpload, useNhostAuth, useNhostBackendUrl, useNhostClient, useProviderLink, useResetPassword, useSendVerificationEmail, useSignInAnonymous, useSignInEmailPassword, useSignInEmailPasswordless, useSignInEmailSecurityKey, useSignInSmsPasswordless, useSignOut, useSignUpEmailPassword, useSignUpEmailSecurityKeyEmail, useUserAvatarUrl, useUserData, useUserDefaultRole, useUserDisplayName, useUserEmail, useUserId, useUserIsAnonymous, useUserLocale, useUserRoles };
//# sourceMappingURL=index.esm.js.map
